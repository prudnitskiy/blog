<!doctype html><html lang=ru-ru data-theme><head><meta charset=utf-8><meta name=HandheldFriendly content="True"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=referrer content="no-referrer-when-downgrade"><title>Systemd – очень быстрый старт - Инфраструктурный блог</title>
<meta name=description content="Очень простое введение в systmed – запуск и управление сервисами в современном linux."><link rel=icon type=image/x-icon href=https://prudnitskiy.pro/favicon.ico><link rel=apple-touch-icon-precomposed href=https://prudnitskiy.pro/favicon.png><style>body{visibility:hidden;opacity:0}</style><noscript><style>body{visibility:visible;opacity:1}</style></noscript><link rel=stylesheet href=/css/style.min.44f8240afd8df81b52565c4119ac5ae247776c77fc6d7ccf6e101a6c98abfa7a.css integrity="sha256-RPgkCv2N+BtSVlxBGaxa4kd3bHf8bXzPbhAabJir+no="><link rel=stylesheet href=/css/style.min.c4c04b3ef88e3d619ad4c7ee5e03048422bc55c4fefdc1f07657c1133670aa22.css integrity="sha256-xMBLPviOPWGa1MfuXgMEhCK8VcT+/cHwdlfBEzZwqiI="><link rel=stylesheet href=/css/style.min.21c5d8fe0a79d623b0adc1ce4bd4f6dd2c05cd939c9aaaa966ba7186b1464f4d.css integrity="sha256-IcXY/gp51iOwrcHOS9T23SwFzZOcmqqpZrpxhrFGT00="><script src=/js/script.min.08f04d96386c73c9bf4d160333f8f448c05a6e01c06770542ee0e013954ce930.js type=text/javascript integrity="sha256-CPBNljhsc8m/TRYDM/j0SMBabgHAZ3BULuDgE5VM6TA="></script><link rel=canonical href=https://prudnitskiy.pro/ru/post/2018-01-24-systemd-quickstart/ itemprop=url></head><body><a class=skip-main href=#main>Перейти к основному контенту</a><div class=container><header class=common-header><div class=header-top><div class=header-top-left><h1 class="site-title noselect"><a href=/ru>Инфраструктурный блог</a></h1><div class=theme-switcher><span class=inline-svg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-sun-high"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M14.828 14.828A4 4 0 109.172 9.172a4 4 0 005.656 5.656z"/><path d="M6.343 17.657l-1.414 1.414"/><path d="M6.343 6.343 4.929 4.929"/><path d="M17.657 6.343l1.414-1.414"/><path d="M17.657 17.657l1.414 1.414"/><path d="M4 12H2"/><path d="M12 4V2"/><path d="M20 12h2"/><path d="M12 20v2"/></svg></span></div><script>const STORAGE_KEY="user-color-scheme",defaultTheme="auto";let currentTheme,switchButton,autoDefinedScheme=window.matchMedia("(prefers-color-scheme: dark)");function switchTheme(){currentTheme=currentTheme==="dark"?"light":"dark",localStorage&&localStorage.setItem(STORAGE_KEY,currentTheme),document.documentElement.setAttribute("data-theme",currentTheme),changeGiscusTheme(currentTheme),document.body.dispatchEvent(new CustomEvent(currentTheme+"-theme-set"))}const autoChangeScheme=e=>{currentTheme=e.matches?"dark":"light",document.documentElement.setAttribute("data-theme",currentTheme),changeGiscusTheme(currentTheme),document.body.dispatchEvent(new CustomEvent(currentTheme+"-theme-set"))};document.addEventListener("DOMContentLoaded",function(){switchButton=document.querySelector(".theme-switcher"),currentTheme=detectCurrentScheme(),currentTheme==="auto"?(autoChangeScheme(autoDefinedScheme),autoDefinedScheme.addListener(autoChangeScheme)):document.documentElement.setAttribute("data-theme",currentTheme),switchButton&&switchButton.addEventListener("click",switchTheme,!1),showContent()});function detectCurrentScheme(){return localStorage!==null&&localStorage.getItem(STORAGE_KEY)?localStorage.getItem(STORAGE_KEY):defaultTheme?defaultTheme:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light"}function showContent(){document.body.style.visibility="visible",document.body.style.opacity=1}function changeGiscusTheme(e){function t(e){const t=document.querySelector("iframe.giscus-frame");if(!t)return;t.contentWindow.postMessage({giscus:e},"https://giscus.app")}t({setConfig:{theme:e}})}</script><ul class="social-icons noselect"><li><a href=https://github.com/prudnitskiy title=Github rel=me><span class=inline-svg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-github"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></span></a></li><li><a href=https://www.linkedin.com/in/prudnitskiy title=Linkedin rel=me><span class=inline-svg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-brand-linkedin"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M4 4m0 2a2 2 0 012-2h12a2 2 0 012 2v12a2 2 0 01-2 2H6a2 2 0 01-2-2z"/><path d="M8 11v5"/><path d="M8 8v.01"/><path d="M12 16v-5"/><path d="M16 16v-3a2 2 0 00-4 0"/></svg></span></a></li><li><a href=/ru/index.xml title=RSS rel=me><span class=inline-svg><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-rss"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 19m-1 0a1 1 0 102 0 1 1 0 10-2 0"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></span></a></li></ul></div><div class=header-top-right></div></div><nav class=noselect><a href=https://prudnitskiy.pro/ru/about/ title=About>About</a>
<a href=https://prudnitskiy.pro/ru/ title=Blog>Blog</a></nav></header><main id=main tabindex=-1><article class="post h-entry"><div class=post-header><header><h1 class="p-name post-title">Systemd – очень быстрый старт</h1></header><div class="post-info noselect"><div class="post-date dt-published"><time datetime=2018-01-24>2018-01-24</time></div><a class="post-hidden-url u-url" href=/ru/post/2018-01-24-systemd-quickstart/>/ru/post/2018-01-24-systemd-quickstart/</a>
<a href=https://prudnitskiy.pro/ class="p-name p-author post-hidden-author h-card" rel=me>map[name:Paul Rudnitskiy]</a><div class=post-taxonomies><ul class=post-tags><li><a href=/ru/tags/linux/>#Linux</a></li></ul></div></div></div><details class="toc noselect"><summary>Table of Contents</summary><div class=inner><nav id=TableOfContents><ul><li><a href=#введение-и-терминология>Введение и терминология</a></li><li><a href=#unit>Unit</a><ul><li><a href=#виды-unit-ов>Виды Unit-ов</a></li><li><a href=#взаимодействие-с-unit-ами>Взаимодействие с unit-ами</a></li><li><a href=#управление-зависимостями-очередность-загрузки-юнитов>Управление зависимостями, очередность загрузки юнитов</a></li></ul></li><li><a href=#targets>Targets</a></li><li><a href=#заключение>Заключение</a></li></ul></nav></div></details><script>var toc=document.querySelector(".toc");toc&&toc.addEventListener("click",function(){event.target.tagName!=="A"&&(event.preventDefault(),this.open?(this.open=!1,this.classList.remove("expanded")):(this.open=!0,this.classList.add("expanded")))})</script><div class="content e-content"><p>При работе в операционной системе нужно постоянно запускать разные программы. Следить за их состоянием. Перезапускать упавшее. Существует целый пласт утилит, который решает эту задачу (от простейшего init.d до навороченного svc). Сейчас в Linux стандартом де-факто стал systemd – его используют все современные дистрибутивы. Это – очень короткое и очень простое введение в systemd. Минимум текста – максимум пользы.</p><p>SystemD – это менеджер загрузки. Он получает управление от ядра при старте операционной системы (init), запускает разные сервисы и следит за их состоянием (например – перезапускает упавшие). Идеолог – Леннар Поттеринг из RedHat. Systemd очень своеобразная штука, умеет она довольно много и устройство у нее довольно сложное. Systemd заслуженно любят за мощный и гибкий функционал – это здорово облегчает жизнь разработчика и админа. Systemd заслуженно ненавидят за тягу к изобретению уже реализованных в операционной системе вещей и спорное поведение в некоторых вопросах безопасности.</p><p>Эта статья – краткое практическое руководство. Теории тут – минимум. Если вас интересует устройство systemd – вам в <a href=https://www.freedesktop.org/software/systemd/man/systemd.unit.html>официальное руководство</a>.</p><h2 id=введение-и-терминология><div><a href=#%d0%b2%d0%b2%d0%b5%d0%b4%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b8-%d1%82%d0%b5%d1%80%d0%bc%d0%b8%d0%bd%d0%be%d0%bb%d0%be%d0%b3%d0%b8%d1%8f>#
</a>Введение и терминология</div></h2><p>Systemd отвечает за запуск программ и сервисов после старта операционной системы. Он следит за процессом загрузки, решает что запустить и как. Строго говоря, он делает ровно то же самое, что делал SystemV init. Systemd писали значительно позже init – в нем пытались <em>починить</em> вещи, которые в init сделаны плохо. Например, в init нет возможности сделать зависимость запуска одного сервиса от другого. Так же init не поддерживает параллельной загрузки. Параллельная загрузка сервисов радикально ускоряет старт операционной системы.</p><h2 id=unit><div><a href=#unit>#
</a>Unit</div></h2><p>Unit – это описание сервиса (в широком смысле этого слова). Unit-файл описывает все настройки сервиса, как его запускать, когда (очередность, зависимости) и что делать, если запуск не удался. Unit-ы, которые пишет пользователь руками – должны находится в <code>/etc/systemd/system</code> и иметь окончание <code>.service</code> в названии. Юниты, которые устанавливают пакеты – находятся в ином месте. Если в нескольких папках лежит юнит с одним и тем же именем – применяется тот, что лежит в <code>/etc/systemd/system</code>. Пример юнита:</p><pre><code>[Unit]
Description=etcd – highly-available key value store
Documentation=https://github.com/coreos/etcd
Documentation=man:etcd
After=network.target
Wants=network-online.target

[Service]
Environment=DAEMON_ARGS=
Environment=ETCD_NAME=%H
EnvironmentFile=-/etc/default/%p
WorkingDir=/var/lib/etcd
Type=notify
User=etcd
PermissionsStartOnly=true
ExecStart=/usr/bin/etcd $DAEMON_ARGS
Restart=on-abnormal
RestartSec=10s
LimitNOFILE=65536

[Install]
WantedBy=multi-user.target
</code></pre><p>Я специально взял юнит посложнее, чтобы пример был наглядным. На что обратить внимание:</p><ul><li>Description – человеко-читаемое описание. Показывается по команде <code>service &lt;name> status</code></li><li>After – начать загрузку после того, как начнется загрузка сервиса (или цели)</li><li>Wants – опциональная зависимость. Подробнее ниже, в разделе про зависимости</li><li>Environment – создать переменную окружения при запуске этого сервиса</li><li>WorkingDir – демон запускается из этой папки. Аналогично <code>cd /var/lib/etcd</code> перед запуском</li><li>Type – тип сервиса. Подробнее ниже</li><li>User – имя пользователя, от которого будет запущен сервис</li><li>PermissionsStartOnly – используется, если перед стартом нужна какая-то специальная подготовка – создание папок, изменение прав и так далее. При <code>PermissionsStartOnly=true</code> эти действия будут выполнятся от root. Без – от имени User</li><li>ExecStart – что, собственно, запускать. Обязательно полный путь</li><li>RestartOn – при каких условиях перезапускать</li><li>WantedBy – в какой target должен быть установлен сервис. Подробнее – в разделе про target-ы</li></ul><h3 id=виды-unit-ов><div><a href=#%d0%b2%d0%b8%d0%b4%d1%8b-unit-%d0%be%d0%b2>##
</a>Виды Unit-ов</div></h3><p>Systemd может обслуживать процессы с разным поведением. Тип описывает, как systemd будет с ним взаимодействовать. Есть следующие варианты:</p><ul><li><code>Type=Simple</code> – самый стандартный тип. Процесс остается в foreground, stdout перехватывается systemd. Это тип по умолчанию.</li><li><code>Type=Forking</code> – прямая противоположность. Процесс должен форкнуться и отсоединится от foreground. Для этого типа юнитов должен быть указан pid через директиву <code>PIDFile</code>.</li><li><code>Type=oneshot</code> – процесс, который успешно выполняется (не делая fork) и завершается. Пример – монтирование файловых систем. Рекомендуется добавить <code>RemainAfterExit=yes</code> в юнит, чтобы результаты работы процесса остался в статусе юнита.</li><li><code>Type=notify</code> – аналог simple, но в этом случае сам процесс сообщит systemd о том, что он закончил загрузку и готов к работе.</li></ul><h3 id=взаимодействие-с-unit-ами><div><a href=#%d0%b2%d0%b7%d0%b0%d0%b8%d0%bc%d0%be%d0%b4%d0%b5%d0%b9%d1%81%d1%82%d0%b2%d0%b8%d0%b5-%d1%81-unit-%d0%b0%d0%bc%d0%b8>##
</a>Взаимодействие с unit-ами</div></h3><p>После каждого изменения файла юнита (создание/изменение/удаление) – нужно перечитывать изменения, так как состояния юнитов systemd кеширует:</p><pre><code>systemctl daemon-reload
</code></pre><p>Запус, состояние, остановка:</p><pre><code>#запуск
systemctl start [unit]
service [unit] start

#состояние
systemctl status [unit]
service [unit] status

#остановка
systemctl stop [unit]
service [unit] stop

#сервис в автозагрузку
systemctl enable [unit]

#полностью запретить запуск сервиса (даже команда service [unit] start не поможет)
systemctl mask [unit]

#разрешить запуск обратно
systemctl unmask [unit]
</code></pre><p>Systemd имеет свою собственную реализацию логирования (хотя по умолчанию в syslog копию сообщения он тоже отправляет). Чтение сообщений от сервисов – командой journalctl. Команда очень мощная, умеет много. Ниже примеры</p><pre><code>#чтение информации по юниту
journalctl -u [UNIT]

#чтение по PID
journalctl _PID=12

#аналогично по конкретному файлу
journalctl /usr/bin/atd

#чтение информаций о юнитах, завершившихся с ошибкой
journalctl -xn

#чтение журнала с момента загрузки
journalctl -b

#чтение журнала с определенного момента
journalctl --since=&quot;2018-01-24 10:15:10&quot;
journalctl --since &quot;10 minutes ago&quot;

#постоянное отслеживание событий (аналог tail -f)
journalctl -f

#по умолчанию systemd обрезает строки по длине экрана. Запретим ему это:
journalctl -l

#фильтры можно комбинировать
journalctl -u redis -f -l --since &quot;10 minutes ago&quot;
</code></pre><h3 id=управление-зависимостями-очередность-загрузки-юнитов><div><a href=#%d1%83%d0%bf%d1%80%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d0%be%d1%81%d1%82%d1%8f%d0%bc%d0%b8-%d0%be%d1%87%d0%b5%d1%80%d0%b5%d0%b4%d0%bd%d0%be%d1%81%d1%82%d1%8c-%d0%b7%d0%b0%d0%b3%d1%80%d1%83%d0%b7%d0%ba%d0%b8-%d1%8e%d0%bd%d0%b8%d1%82%d0%be%d0%b2>##
</a>Управление зависимостями, очередность загрузки юнитов</div></h3><p>Для управления зависимостями в unit есть ключевые слова <code>Wants</code>, <code>Requires</code> и <code>After</code>:</p><ul><li><code>After</code> – сервис начнет загрузку после того, как <strong>начнет</strong> загружаться сервис, указанный в <code>After</code>.</li><li><code>Wants</code> – сервис начнет загрузку после того, как <strong>закончит</strong> загружаться сервис, указанный в <code>Wants</code>. Статус загрузки этого сервиса не важен – даже если он упал и загрузится не смог – юнит попытается стартовать. То есть зависимость эта опциональная, и нужна она только для того, чтобы наш сервис начал загружаться не раньше, чем другой – закончит.</li><li><code>Requires</code> – сервис начнет загрузку после того, как сервис, указанный в <code>Requires</code> закончит загрузку <strong>успешно</strong>. Если сервис-зависимость загрузится не смог – наш сервис так же упадет с ошибкой (точнее – он даже не будет стартовать).</li></ul><h2 id=targets><div><a href=#targets>#
</a>Targets</div></h2><p>Target – целевое состояние системы. Именно Target определяет, какие сервисы будут загружены и в каком порядке. Аналог из мира sysV init – runlevel. Основные виды таргетов:</p><ul><li><code>poweroff</code> – отключение системы</li><li><code>rescue</code> – режим восстановления, однопользовательский (init 1)</li><li><code>multi-user</code> – сетевой режим без графической оболочки, (init 3)</li><li><code>graphical</code> – сетевой режим с графической оболочкой (init 5)</li><li><code>reboot</code> – перезагрузка</li><li><code>emergency</code> – аварийная командная строка, минимальный функционал</li></ul><p>Цели могут наследоваться друг от друга. Например, graphical включает в себя загрузку всего, что есть multiuser + после этого – подгрузку графической оболочки.</p><p>Взаимодействие с целями:</p><pre><code>#список целей
systemctl list-units --type=target

#перейти в нужную цель (например – загрузится из сетевого режима в графический)
systemctl isolate graphical.target

#выбрать target по умолчанию
systemctl set-default multi-user.target
</code></pre><h2 id=заключение><div><a href=#%d0%b7%d0%b0%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5>#
</a>Заключение</div></h2><p>systemd на данный момент - стандарт в linux-based операционных системах. Инструмент мощный, удобный и популярный, пусть и не без особенностей. Надеюсь, эта статья поможет начать им пользоваться.</p></div></article><h3 class="read-next-title noselect">Читать далее</h3><ul class="read-next-posts noselect"><li><a href=/ru/post/2015-11-26-pinba/>Отслеживаем PHP с помощью PINBA на debian</a></li><li><a href=/ru/post/2014-12-25-debian-to-mdraid/>Мигрируем Debian на softraid без потери данных</a></li><li><a href=/ru/post/2013-06-20-rails-on-uwsgi/>Запуск ruby on rails на uwsgi на примере redmine</a></li></ul><div class="pagination post-pagination"><div class="left pagination-item"><a href=/ru/post/2018-08-02-yubikey-gpg/>Yubikey + GPG – быстрый старт</a></div><div class="right pagination-item"><a href=/ru/post/2018-01-05-pgsql-replica/>Потоковая репликация в PostgreSQL – короткое введение</a></div></div></main><footer class="common-footer noselect"><ul class=language-select><li>Русский</li><li><a href=/en/>English</a></li></ul><div class=common-footer-bottom><div style=display:flex;align-items:center;gap:8px>© Paul Rudnitskiy, 2025</div><div style=display:flex;align-items:center></div><div>Движок <a target=_blank rel="noopener noreferrer" href=https://gohugo.io/>Hugo</a>, тема <a target=_blank rel="noopener noreferrer" href=https://github.com/Junyi-99/hugo-theme-anubis2>Anubis2</a>.<br></div></div><p class="h-card vcard"><a href=https://prudnitskiy.pro/ class="p-name u-url url fn" rel=me>map[name:Paul Rudnitskiy]</a></p></footer></div></body></html>