<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on Инфраструктурный блог</title><link>/ru/tags/security/</link><description>Инфраструктурный блог (Security)</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Wed, 24 Jul 2019 12:00:00 +0000</lastBuildDate><atom:link href="/ru/tags/security/index.xml" rel="self" type="application/rss+xml"/><item><title>WireGuard: перспективный VPN</title><link>/ru/post/2019-07-24-wireguard/</link><pubDate>Wed, 24 Jul 2019 12:00:00 +0000</pubDate><guid>/ru/post/2019-07-24-wireguard/</guid><description>&lt;p>VPN придуман давно (IPSec - в 1998 году, например) и имеет множество областей применения - безопасный доступ для удаленных сотрудников, прозрачное объединение корпоративных сетей, безопасный доступ в интернет поверх небезопасных каналов, даже - уклонение от корпоративной и государственной цензуры. Протоколов VPN - целый выводок, а реализации (программы, ПАК, даже чистые аппаратные решения без ПО есть) - еще больше. При этом каждый каждый стандарт имеет свои недостатки. WireGuard - это очередной протокол VPN, попытка эти проблемы решить. При всех плюсах WG (про них - ниже) - он мало известен и на удивление плохо документирован. Эта статья - попытка устранить эти недостатки.&lt;/p>
&lt;p>WireGuard - это протокол VPN, который был придуман и реализован полностью с нуля - с применением последних, самых свежих концепций в программировании и криптографии. Главная задача, которую ставил перед собой автор (Джейсон Доненфелд) - простота протокола и реализации и высокая скорость работы. Протокол предельно простой, по-моему даже PPP сложнее. Очень простое взаимодействие операционной системы с VPN - WireGuard добавляет в систему сетевой интерфейс типа wireguard (по умолчанию - wgX), маршрутизация трафика идет через него. VPN полностью реализован на уровне ядра (для Linux, для других операционных систем поддерживается работа в виде обычной программы) - он очень быстро работает. Трафик упаковывается в совершенно типовой UDP, не нужны специфичные IP-протоколы (как это сделано в PPP/IPSec). Автор решил не использовать классические legacy-протоколы шифрования и взял самые свежие, но доказанно безопасные протоколы:&lt;/p>
&lt;ul>
&lt;li>ChaCha20 (salsa) - симметричное потоковое шифрование данных&lt;/li>
&lt;li>Curve25519 ECDH - ассиметричное шифрование для авторизации и аутентификации&lt;/li>
&lt;li>Blake2s - для хеширования&lt;/li>
&lt;/ul>
&lt;p>По скорости работы WireGuard обгоняет IPSec, даже с учетом того, что IPSec жульничает - современные CPU часть криптопримитивов могут выполнять в одну инструкцию.&lt;/p>
&lt;p>При этом по простоте и удобству настройки WireGuard проще OpenVPN.&lt;/p>
&lt;p>В качестве бонуса - Торвальдс очень хвалил код WireGuard (а Торвальдс известен нетерпимостью к плохому коду и не станет раздавать незаслуженные комплименты) и обещал, что код войдет в базовое ядро в ближайшем будущем. Звучит очень интересно, не так ли?&lt;/p>
&lt;p>Разумеется, минусы у него тоже есть, и не упомянуть их было неправильно:&lt;/p>
&lt;ul>
&lt;li>wireguard формально находится в стадии активной разработки. До сих пор не вышло ни одной формальной версии, то есть даже wireguard 0.0.0.1 - нет в природе. Авторы не обещают и не гарантируют обратной совместимости протокола, то есть при одном удачном обновлении у вас легко может рассыпаться сеть. За пол-года, что я использовал WG - у меня такого не было ни разу, но в теории такая возможность сохраняется до выхода стабильной версии.&lt;/li>
&lt;li>wireguard не является стандартным и стабильным решением, не существует физического устройства, которое его поддерживает официально (как IPSec, например). Частично можно компенсировать тем, что все современные linux-based прошивки для маршрутизаторов (dd-wrt, OpenWRT, tomato) - поддерживают его с минимальным набором телодвижений. OpenVPN это обстоятельство, кстати, никак не мешает - из железяк его поддерживает разве что mikrotik и делает это настолько отвратительно, что лучше бы не поддерживал вовсе.&lt;/li>
&lt;li>wireguard не проходил формального аудита безопасности. Протоколы, которые он используют - аудит проходили, реализация - нет. Прохождение аудита у авторов запланировано после стабилизации кодовой базы. Как следствие - сертифицировать решение на базе wireguard невозможно. Если вы работаете в банке - пожалуйста, не используйте wireguard.&lt;/li>
&lt;li>криптопримитивы в wireguard прибиты гвоздиками и поменять их невозможно. Только ECDH для авторизации, только salsa20 для потоковых шифров, только UDP в качестве транспорта. С одной стороны - это здорово упрощает жизнь &amp;ndash; невозможно перепутать настройки протоколов и провести пару вечеров за отладкой. С другой - если в каком-то из этих примитивов найдут серьезную дыру - придется переписать пол-протокола или вообще все выкинуть. Частично компенсируется тем, что весь Bitcoin (и не только он) построен вокруг ECDH, так что если там найдут дыру - проблемы wiregaurd будут мелочью.&lt;/li>
&lt;/ul>
&lt;p>В целом я могу уверенно рекомендовать wireguard для личного использования или как VPN-протокол в малокритичных сетях (без SLA и с командой, которая готова с ним разбираться). В общем случае, если у вас есть OpenVPN на linux - WireGuard идеально может его заменить. WireGuard напоминает мне OpenVPN в те времена, когда тот еще только появился и не успел стать legacy - простой, удобный, быстрый в настройке VPN.&lt;/p>
&lt;h2 id="установка" >
&lt;div>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0">
#
&lt;/a>
Установка
&lt;/div>
&lt;/h2>
&lt;h3 id="debianubuntu" >
&lt;div>
&lt;a href="#debianubuntu">
##
&lt;/a>
Debian/Ubuntu
&lt;/div>
&lt;/h3>
&lt;p>Так, как стабильных релизов wireguard нет - нам потребуется DKMS для сборки модулей ядра. Пакеты для WireGuard для debian stretch/buster не выпускались, но они есть для debian sid. Добавим репозиторий unstable и создадим pin. Если добавить репозиторий и не создавать пин - все пакеты из sid приедут в ваш сервер. Удачно запущенный apt-get install превратит систему в кашу:&lt;/p>
&lt;pre>&lt;code># echo &amp;quot;deb http://deb.debian.org/debian/ sid main&amp;quot; &amp;gt; /etc/apt/sources.list.d/unstable.list
# printf 'Package: *\nPin: release a=unstable\nPin-Priority: 90\n' &amp;gt; /etc/apt/preferences.d/limit-unstable.pref
&lt;/code>&lt;/pre>
&lt;p>К счастью, в ubuntu все необходимые пакеты уже есть и дополнительные телодвижения не нужны. Ставим модуль:&lt;/p>
&lt;pre>&lt;code># apt-get update
# apt-get install wireguard wireguard-dkms wireguard-tools
&lt;/code>&lt;/pre>
&lt;p>Проверим, что все установилось:&lt;/p>
&lt;pre>&lt;code># ip link add dev wg0 type wireguard
# ip link print
1: lo: &amp;lt;LOOPBACK,UP,LOWER_UP&amp;gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1
link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
[...]
25: wg0: &amp;lt;POINTOPOINT,NOARP&amp;gt; mtu 1420 qdisc noop state DOWN mode DEFAULT group default qlen 1
link/none
&lt;/code>&lt;/pre>
&lt;h3 id="centosrheloracleubl" >
&lt;div>
&lt;a href="#centosrheloracleubl">
##
&lt;/a>
CentOS/RHEL/OracleUBL
&lt;/div>
&lt;/h3>
&lt;p>Владельцам rpm-based дистрибутивов повезло больше - есть готовый отдельный репозиторий, так что достаточно поставить его и EPEL (хотя мне сложно представить rpm-based дистрибутив без EPEL):&lt;/p>
&lt;pre>&lt;code># curl -Lo /etc/yum.repos.d/wireguard.repo https://copr.fedorainfracloud.org/coprs/jdoss/wireguard/repo/epel-7/jdoss-wireguard-epel-7.repo
# yum makecache
# yum install epel-release
# yum install wireguard-dkms wireguard-tools
&lt;/code>&lt;/pre>
&lt;h2 id="настройка" >
&lt;div>
&lt;a href="#%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0">
#
&lt;/a>
Настройка
&lt;/div>
&lt;/h2>
&lt;h3 id="сервер" >
&lt;div>
&lt;a href="#%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80">
##
&lt;/a>
Сервер
&lt;/div>
&lt;/h3>
&lt;p>Wireguard использует авторизацию только по ключам (keypair). Ключи генерирует сам. Авторизация клиента производится по его публичному ключу, то есть на сервере должны быть публичные ключи всех клиентов, а на клиентах - публичный ключ сервера. Создадим такой ключ:&lt;/p>
&lt;pre>&lt;code>server# umask 077
server# wg genkey &amp;gt; server.priv
server# wg pubkey &amp;lt; server.priv &amp;gt; server.pub
&lt;/code>&lt;/pre>
&lt;p>На выходе получим два ключа, приватный и публичный. В принципе wireguard можно полностью управлять через команду ip, но это не сказать, чтобы сильно удобно. Для того, чтобы упростить настройку, авторы wireguard написали утилиту &lt;code>wg-quick&lt;/code>. Она читает конфиг из &lt;code>/etc/wireguard/wgX.conf&lt;/code> и создает соответствующий интерфейс. Пример конфига &lt;code>/etc/wireguard/wg0.conf&lt;/code>:&lt;/p>
&lt;pre>&lt;code>[Interface]
Address = 192.168.254.1/24
SaveConfig = false
ListenPort = 25968
PrivateKey = [...]
PostUp = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
PostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE
&lt;/code>&lt;/pre>
&lt;p>Что тут написано:&lt;/p>
&lt;ul>
&lt;li>&lt;code>address&lt;/code> - адресное пространство VPN-сети. Этот адрес будет присвоен интерфейсу wg0. Все клиенты, которые подключены к одному интерфейсу - должны иметь адреса в одной подсети, иначе они не смогут общаться.&lt;/li>
&lt;li>&lt;code>saveconfig = false&lt;/code> - если что-то было изменено после wg-quick вручную (командой ip link) - по умолчанию изменения запишутся в конфиг. Побочный эффект - если во время работы wireguard вы что-то в конфиге поменяете и перезапустите wireguard - все изменения будут стерты.&lt;/li>
&lt;li>&lt;code>ListenPort&lt;/code> - на какой порт должны приходить UDP-датаграммы, предназначенные для этого конкретного интерфейса wireguard. Никто не запрещает создать несколько интерфейсов wireguard - каждый с отдельным ключом, адресным пространством и списком клиентов. Этот порт должен быть открыт снаружи для UDP&lt;/li>
&lt;li>&lt;code>PrivateKey&lt;/code> - ключ из server.priv (из шага выше).&lt;/li>
&lt;li>&lt;code>PostUp&lt;/code> - добавляет правила в фаерволл - разрешает форвардинг для интерфейса и включает nat. Эта строка вам не нужна, если правила добавлены вручную. В данном примере считается, что внешний интерфейс сервера - eth0.&lt;/li>
&lt;li>&lt;code>PostDown&lt;/code> - удаляет правила, который добавил &lt;code>PostUp&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>На всякий случай включим форвардинг пакетов:&lt;/p>
&lt;pre>&lt;code>server# sysctl -w net.ipv4.ip_forward=1
server# echo &amp;quot;net.ipv4.ip_forward=1&amp;quot; &amp;gt;&amp;gt; /etc/sysctl.conf
&lt;/code>&lt;/pre>
&lt;h3 id="клиент" >
&lt;div>
&lt;a href="#%d0%ba%d0%bb%d0%b8%d0%b5%d0%bd%d1%82">
##
&lt;/a>
Клиент
&lt;/div>
&lt;/h3>
&lt;p>Точно так же ставим wireguard и генерируем ключи, как в примере выше:&lt;/p>
&lt;pre>&lt;code>client# umask 077
client# wg genkey &amp;gt; client.priv
client# wg pubkey &amp;lt; client.priv &amp;gt; client.pub
&lt;/code>&lt;/pre>
&lt;p>А вот содержимое конфига будет слегка иным:&lt;/p>
&lt;pre>&lt;code>[Interface]
PrivateKey = &amp;lt;from client.priv&amp;gt;
Address = 192.168.254.2/24
ListenPort = 25967
Table=wire
[Peer]
PublicKey = &amp;lt;from server.pub&amp;gt;
Endpoint = &amp;lt;server ip&amp;gt;:25968
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 30
&lt;/code>&lt;/pre>
&lt;p>Что появилось в конфиге нового. Секция Interface как и раньше - отвечает за настройку самого сервиса wiregurad:&lt;/p>
&lt;ul>
&lt;li>&lt;code>Address&lt;/code> - из той же подсети, что и адрес сервера, но уникальный.&lt;/li>
&lt;li>&lt;code>Table = wire&lt;/code> - нужно, чтобы wireguard знал, в какую таблицу записывать маршруты. Они описаны в разделе peer (о нем ниже) и в момент, когда связь с peer-ом (сервером) будет установлена - маршруты будут добавлены. Если таблицу не указывать - будет использована системная. Это может вызвать проблему, если VPN выдает маршрут по умолчанию (как здесь). Чуть ниже я покажу, как с этим жить.&lt;/li>
&lt;/ul>
&lt;p>Секция peer настраивает параметры подключения к другой стороне:&lt;/p>
&lt;ul>
&lt;li>&lt;code>PublicKey&lt;/code> - публичный ключ сервера. Именно по нему клиент авторизует сервер.&lt;/li>
&lt;li>&lt;code>Endpoint&lt;/code> - внешний адрес и порт сервера.&lt;/li>
&lt;li>&lt;code>AllowedIPs&lt;/code> - обращения к каким адресам можно отправлять в этот туннель. При поднятии туннеля маршрут ко всем адресам (сетям), перечисленным тут - будет добавлен в таблицу маршрутизации из секции Interface. Если какой-то сети или адреса тут нет - ручное добавление маршрута не поможет, wireguard отклонит такой маршрут. В данном примере я использую wireguard-сервер как шлюз по умолчанию, то есть хожу в интернет через него. Если сетей нужно добавить несколько - их можно перечислить через запятую.&lt;/li>
&lt;li>&lt;code>PersistentKeepalive&lt;/code> - интервал keepalive в секундах. По умолчанию данные в туннеле есть только тогда, когда кто-то что-то через него передает. KeepAlive периодически пингует удаленную сторону и поддерживает соединение. Это важно в тех случаях, если вы сидите за nat - сервер не может поддерживать соединение с клиентом, nat gateway разорвет неактивное соединение. Если после этого сервер захочет передать пакет клиенту - он не сможет этого сделать.&lt;/li>
&lt;/ul>
&lt;p>Включаем wiregurad на клиенте и идем настраивать на сервер:&lt;/p>
&lt;pre>&lt;code>client# wg-quick up wg0
&lt;/code>&lt;/pre>
&lt;p>Чтобы клиент запускал wireguard автоматически - добавим его в автозагрузку:&lt;/p>
&lt;pre>&lt;code>client# systemctl enable wg-quick@wg0
&lt;/code>&lt;/pre>
&lt;h3 id="снова-сервер" >
&lt;div>
&lt;a href="#%d1%81%d0%bd%d0%be%d0%b2%d0%b0-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80">
##
&lt;/a>
Снова сервер
&lt;/div>
&lt;/h3>
&lt;p>В &lt;code>/etc/wireguard/wg0.conf&lt;/code> нужно вписать клиента, которого мы только что создали выше. Добавим секцию:&lt;/p>
&lt;pre>&lt;code>[Peer]
PublicKey = &amp;lt;from client.pub&amp;gt;
AllowedIPs = 192.168.254.2/32, 192.168.1.1/24
Endpoint = &amp;lt;client public IP&amp;gt;:25967
&lt;/code>&lt;/pre>
&lt;p>Обратите внимание на то, что в AllowedIPs указан, в том числе, адрес интерфейса wireguard &lt;em>на клиенте&lt;/em>. Это очень важно, без этого трафик ходить не будет. Про него часто забывают. В примере выше через VPN маршрутизируется сеть &lt;code>192.168.1.0/24&lt;/code>, потому она указана тоже.&lt;/p>
&lt;p>Поднимем VPN на сервере тоже и проверим:&lt;/p>
&lt;pre>&lt;code>server# wg-quick up wg0
server# wg show
interface: wg0
public key: [...]
private key: (hidden)
listening port: 25968
peer: [...]
endpoint: 1.2.3.4:25967
allowed ips: 192.168.254.2/32, 192.168.1.0/24
latest handshake: 1 minute, 35 seconds ago
transfer: 1.84 KiB received, 2.84 KiB sent
&lt;/code>&lt;/pre>
&lt;p>Настройка VPN, в общем-то, закончена. Как я и говорил выше - восхитительно просто.&lt;/p>
&lt;h4 id="лирическое-отступление-маршрутизация-через-таблицы-и-маркировка-трафика" >
&lt;div>
&lt;a href="#%d0%bb%d0%b8%d1%80%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b5-%d0%be%d1%82%d1%81%d1%82%d1%83%d0%bf%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bc%d0%b0%d1%80%d1%88%d1%80%d1%83%d1%82%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f-%d1%87%d0%b5%d1%80%d0%b5%d0%b7-%d1%82%d0%b0%d0%b1%d0%bb%d0%b8%d1%86%d1%8b-%d0%b8-%d0%bc%d0%b0%d1%80%d0%ba%d0%b8%d1%80%d0%be%d0%b2%d0%ba%d0%b0-%d1%82%d1%80%d0%b0%d1%84%d0%b8%d0%ba%d0%b0">
###
&lt;/a>
Лирическое отступление: маршрутизация через таблицы и маркировка трафика
&lt;/div>
&lt;/h4>
&lt;p>Как я уже упоминал выше - по умолчанию wireguard добавляет все маршруты, указанные в AllowedIPs в основную таблицу маршрутизации. Linux не поддерживает policy based routing, соответственно там нельзя создать &amp;ldquo;условные маршруты&amp;rdquo; вида &amp;ldquo;если клиент из офисной сети - маршрут в google пустить через VPN&amp;rdquo;. Default gateway через VPN вообще кончится потерей связи, так как сервер потеряет маршрут до VPN-сервера. Выход есть - и называется он &amp;ldquo;таблицы маршрутизации&amp;rdquo;. Linux поддерживает 255 таблиц маршрутизации (точнее - 251, так как есть зарезервированные таблицы, которые нельзя удалить). Для решения перечисленных выше проблем мы просто создадим отдельную таблицу маршрутизации, а потом с помощью iptables будем ловить трафик, предназначенный для VPN и отправлять его в нужную нам таблицу. При этом клиентская сеть сохранит доступ к серверу и мы сможем гибко настраивать потоки трафика. К примеру - пустить через VPN только трафик для google/youtube, а трафик в Яндекс пустить по старому маршруту по умолчанию. Создадим таблицу:&lt;/p>
&lt;pre>&lt;code>client# echo &amp;quot;200 wire&amp;quot; &amp;gt;&amp;gt; /etc/iproute2/rt_tables
Теперь создадим правило iptables, которое будет помечать нужный нам трафик. Этот трафик должен быть отправлен в VPN:
client# iptables -I PREROUTING -t mangle -i eth0 -j MARK --set-mark 1
&lt;/code>&lt;/pre>
&lt;p>В данном примере я отправляю в VPN весь трафик, который приходит на интерфейс eth0 (в моем случае это внутренний интерфейс)&lt;/p>
&lt;p>Теперь нам нужно правило (ip rule), которое перенаправит трафик с меткой 0х1 в таблицу wire:&lt;/p>
&lt;pre>&lt;code>ip rule add fwmark 0x1 lookup wire
&lt;/code>&lt;/pre>
&lt;p>Чтобы правило не потерялось при перезагрузке сервера или пересоздании интерфейса - я набросал простейший скрипт и положил его в &lt;code>/etc/network/if-up.d&lt;/code> (это пример для debian). Таким образом правило будет добавляться каждый раз, когда интерфейс переходит в активное состояние (UP):&lt;/p>
&lt;pre>&lt;code>#!/bin/bash
if [[ ! $(ip rule list | grep &amp;quot;fwmark 0x1 lookup wire&amp;quot;) ]]; then
/bin/ip rule add fwmark 0x1 lookup wire
fi
&lt;/code>&lt;/pre>
&lt;p>Этому скрипту нужно обязательно дать права на выполнение (chmod +x). Название скрипта не важно совершенно, главное - место, где файл лежит и права.&lt;/p>
&lt;p>Еще одну проблему подарит rpfilter. В нормальной ситуации это полезная настройка - она позволяет отсекать фальшивые (forged) пакеты, которые пришли не на тот интефейс, с которого уходили. К примеру, у нас есть eth0 (192.168.1.1) и eth1 (172.16.1.1). Пакет отправляется с source address 192.168.1.2 (интерфейс eth0) а ответ приходит на eth1. Это или что-то странное (что редкость) или попытка взлома (что более вероятно). RPFilter отсекает такие пакеты. Проблема в том, что с точки зрения rpfilter пакеты, уходящие в другую таблицу - будут &amp;ldquo;проваливаться в никуда&amp;rdquo;, а ответные - &amp;ldquo;возникать из ниоткуда&amp;rdquo;. Чудеса телепортации rpfilter не любит, так что его придется отключить, иначе не видать вам трафика через vpn:&lt;/p>
&lt;pre>&lt;code>client# sysctl -w net.ipv4.conf.eth0.rp_filter=2
client# sysctl -w net.ipv4.conf.wg0.rp_filter=2
&lt;/code>&lt;/pre>
&lt;p>Чтобы эти изменения не пропали при перезагрузке - добавим их в &lt;code>/etc/sysctl.conf&lt;/code>:&lt;/p>
&lt;pre>&lt;code>client# printf &amp;quot;net.ipv4.conf.eth0.rp_filter=2\nnet.ipv4.conf.wg0.rp_filter=2&amp;quot; &amp;gt;&amp;gt; /etc/sysctl.conf
&lt;/code>&lt;/pre>
&lt;h4 id="лирическое-отступление-номер-два-добавляем-исключения-ipset" >
&lt;div>
&lt;a href="#%d0%bb%d0%b8%d1%80%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b5-%d0%be%d1%82%d1%81%d1%82%d1%83%d0%bf%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%bd%d0%be%d0%bc%d0%b5%d1%80-%d0%b4%d0%b2%d0%b0-%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%bb%d1%8f%d0%b5%d0%bc-%d0%b8%d1%81%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d1%8f-ipset">
###
&lt;/a>
Лирическое отступление номер два: добавляем исключения. IPSET.
&lt;/div>
&lt;/h4>
&lt;p>Иногда хочется пустить через VPN только часть трафика или наоборот - исключить часть трафика из прохождения через VPN. В принципе все это можно сделать исключительно правилами чистого iptables. Например, VPN для нескольких серверов будет выглядеть примерно так:&lt;/p>
&lt;pre>&lt;code>iptables -I PREROUTING -t mangle -i eth0 -d 1.2.3.4 -j MARK --set-mark 1
iptables -I PREROUTING -t mangle -i eth0 -d 1.2.5.5 -j MARK --set-mark 1
iptables -I PREROUTING -t mangle -i eth0 -d 1.2.5.6 -j MARK --set-mark 1
iptables -I PREROUTING -t mangle -i eth0 -d 1.2.6.7 -j MARK --set-mark 1
iptables -I PREROUTING -t mangle -i eth0 -d 1.2.7.8 -j MARK --set-mark 1
&lt;/code>&lt;/pre>
&lt;p>Выглядит, честно говоря, ужасно. Что намного хуже - работать будет довольно медленно, поскольку &lt;em>каждый пакет проходит все правила iptables по очереди - пока не наткнется на правило, которое его обработает&lt;/em>. Пара тысяч правил застави задуматься даже весьма приличный сервер. Пара миллионов - уложит машину на лопатки, пакеты будут путешествовать по недрам netfilter минутами - это вечность. Для решения этой проблемы был придуман ipset. IPSet - это простой и очень эффективный способ хранить множество адресов в памяти компактно, а искать в этом списке - быстро. Память выделяется для ipset в момент создания set (даже, если set пуст). IPSet в кратчайшие сроки ответит на вопрос - есть ли в нем тот или иной адрес - время ответа приближено к O(1), то есть скорость проверки наличия адреса в ipset в общем-то не зависит от размера. В штатную поставку операционной системы ipset не входит, но ставится очень легко:&lt;/p>
&lt;pre>&lt;code>client# apt-get install ipset
&lt;/code>&lt;/pre>
&lt;p>IPSet предоставляет разные варианты sets - они позволяют хранить разные вещи, но требуют разного количества памяти на одну запись. Для примера создадим set, который хранит подсети (адрес + маску):&lt;/p>
&lt;pre>&lt;code>client# ipset create novpn hash:net hashsize 65535
&lt;/code>&lt;/pre>
&lt;p>это создаст set novpn емкостью 65535 записей. Изменить размер или тип сета после создания будет нельзя, так что выбирать придется с умом.&lt;/p>
&lt;p>Удалим старое правило (которое отправляет в VPN весь трафик из внутренней сети) и добавим новое - оно будет отправлять трафик в VPN, если адреса нет в set-е novpn:&lt;/p>
&lt;pre>&lt;code>client# iptables -t mangle -D PREROUTING 1
client# iptables -I PREROUTING -t mangle -i eth0 -m set ! --match-set novpn dst -j MARK --set-mark 1
&lt;/code>&lt;/pre>
&lt;p>Теперь добавим какое-нибудь исключение. Например, avito.ru очень не любит дешевые VPS, на которых часто делают VPN-сервера - мошенники активно используют такие же сервера, чтобы воровать с авито данные, а потому большинство сетей крупнейших облачных провайдеров на авито просто забанены.&lt;/p>
&lt;pre>&lt;code>client# ipset add novpn 185.89.12.0/24
&lt;/code>&lt;/pre>
&lt;p>Проверим:&lt;/p>
&lt;pre>&lt;code>client# ipset list
Name: novpn
Type: hash:net
Revision: 6
Header: family inet hashsize 65536 maxelem 65536
Size in memory: 1376
References: 1
Members:
185.89.12.0/24
&lt;/code>&lt;/pre>
&lt;p>Теперь трафик к avito (185.89.12.0/24) пойдет напрямую, а весь остальной - через VPN.&lt;/p>
&lt;p>К слову - можно сделать и наоборот, то есть пустить через VPN трафик, который попадает в ipset. Правило будет выглядеть чуть-чуть иначе:&lt;/p>
&lt;pre>&lt;code>client# iptables -I PREROUTING -t mangle -i eth0 -m set --match-set tovpn dst -j MARK --set-mark 1
&lt;/code>&lt;/pre>
&lt;p>Все остальные принципы работы с ipset сохраняются. Рекомендую.&lt;/p>
&lt;h3 id="клиент-отдельный-ноутбук-на-linux-roadwarrior" >
&lt;div>
&lt;a href="#%d0%ba%d0%bb%d0%b8%d0%b5%d0%bd%d1%82-%d0%be%d1%82%d0%b4%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b9-%d0%bd%d0%be%d1%83%d1%82%d0%b1%d1%83%d0%ba-%d0%bd%d0%b0-linux-roadwarrior">
##
&lt;/a>
Клиент: отдельный ноутбук на linux (roadwarrior)
&lt;/div>
&lt;/h3>
&lt;p>Wireguard ставится ровно так же, как в примере выше:&lt;/p>
&lt;pre>&lt;code>notebook# apt-get install wireguard wireguard-dkms wireguard-tools
&lt;/code>&lt;/pre>
&lt;p>С ключами тоже никаких сюрпризов:&lt;/p>
&lt;pre>&lt;code>notebook# umask 077
notebook# wg genkey &amp;gt; notebook.priv
notebook# wg pubkey &amp;lt; notebook.priv &amp;gt; notebook.pub
&lt;/code>&lt;/pre>
&lt;p>Ключи создаются точно так же. Пример конфига ноутбука (&lt;code>/etc/wireguard/wg0.conf&lt;/code>):&lt;/p>
&lt;pre>&lt;code>[Interface]
PrivateKey = &amp;lt;from notebook.priv&amp;gt;
Address = 192.168.254.2/24
[Peer]
PublicKey = &amp;lt;from server.pub&amp;gt;
Endpoint = 1.2.3.4:25967
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 21
&lt;/code>&lt;/pre>
&lt;p>Включаем командой &lt;code>wg-quick up wg0&lt;/code>. Выключаем, соответственно - &lt;code>wg-quick down wg0&lt;/code>. Интеграции с netmanager пока что нет, так что включать-выключать конфиг графической кнопкой не выйдет.&lt;/p>
&lt;p>Не забудьте добавить содержимое &lt;code>notebook.pub&lt;/code> на сервер - в секцию &lt;code>[Peer]&lt;/code>.&lt;/p>
&lt;h3 id="задача-со-звездочкой---подключаем-мобильное-устройство" >
&lt;div>
&lt;a href="#%d0%b7%d0%b0%d0%b4%d0%b0%d1%87%d0%b0-%d1%81%d0%be-%d0%b7%d0%b2%d0%b5%d0%b7%d0%b4%d0%be%d1%87%d0%ba%d0%be%d0%b9---%d0%bf%d0%be%d0%b4%d0%ba%d0%bb%d1%8e%d1%87%d0%b0%d0%b5%d0%bc-%d0%bc%d0%be%d0%b1%d0%b8%d0%bb%d1%8c%d0%bd%d0%be%d0%b5-%d1%83%d1%81%d1%82%d1%80%d0%be%d0%b9%d1%81%d1%82%d0%b2%d0%be">
##
&lt;/a>
Задача со звездочкой - подключаем мобильное устройство
&lt;/div>
&lt;/h3>
&lt;p>Wireguard есть как для iOS, так и для android. В первом случае он сделан как userspace процесс, но протокол реализует тот же. Работает, конечно, медленнее, но не думаю, что это будет заметно. Ставится как любое типичное приложение, а вот настройки создаются интересно.&lt;/p>
&lt;p>Создадим на сервере ключи для мобильного:&lt;/p>
&lt;pre>&lt;code>server# wg genkey | tee mobile.priv | wg pubkey &amp;gt; mobile.pub
&lt;/code>&lt;/pre>
&lt;p>Добавим еще один peer в конфиг сервера:&lt;/p>
&lt;pre>&lt;code>[Peer]
PublicKey = &amp;lt;from mobile.pub&amp;gt;
AllowedIPs = 192.168.254.3/32
&lt;/code>&lt;/pre>
&lt;p>Перезапустим wg:&lt;/p>
&lt;pre>&lt;code>server# wg-quick down wg0
server# wg-quick up wg0
&lt;/code>&lt;/pre>
&lt;p>создадим конфиг для мобильного с примерно таким содержимым:&lt;/p>
&lt;pre>&lt;code>[Interface]
PrivateKey = &amp;lt;from mobile.priv&amp;gt;
Address = 192.168.254.3/32
DNS = 8.8.8.8
[Peer]
PublicKey = &amp;lt;from server.pub&amp;gt;
Endpoint = 1.2.3.4:25967
AllowedIPs = 0.0.0.0/0
&lt;/code>&lt;/pre>
&lt;p>В целом все выглядит знакомо. Теперь нужно передать конфиг на мобильное устройство. Проще всего это сделать, закодировав конфиг в QR-code:&lt;/p>
&lt;pre>&lt;code>server# qrencode -t ansiutf8 &amp;lt; mobile.conf
&lt;/code>&lt;/pre>
&lt;p>На выходе будет картинка - QR-код. Открываем wireguard на мобильном, жмем + -&amp;gt; from QR code -&amp;gt; показываем картинку. Готово, мобильное устройство получило конфиг и теперь VPN можно включать штатными средствами.&lt;/p>
&lt;p>Ключи mobile и конфиг рекомендуется удалить с сервера - чтобы никто их не украл.&lt;/p>
&lt;h2 id="выводы" >
&lt;div>
&lt;a href="#%d0%b2%d1%8b%d0%b2%d0%be%d0%b4%d1%8b">
#
&lt;/a>
Выводы
&lt;/div>
&lt;/h2>
&lt;p>WireGuard - прекрасная альтернатива openvpn уже сейчас. Простой, легко и быстро настраиваемый сервис. Работает очень стабильно, при этом - очень быстро. Я горячо рекомендую его как замену openvpn - как в корпоративном секторе, так и для личного использования.&lt;/p>
&lt;p>Безопасного вам интернета!&lt;/p></description></item><item><title>CFSS: TLS CA со скоростью молнии</title><link>/ru/post/2018-12-14-cfssl/</link><pubDate>Fri, 14 Dec 2018 12:00:00 +0000</pubDate><guid>/ru/post/2018-12-14-cfssl/</guid><description>&lt;p>TLS - один из самых распространенных стандартов шифрования и аутентификации в современном интернете. Используется исключительно широко - взаимодействие с пользователем (HTTPS), межпрограммное общение (RPC over HTTPS, gRPC), даже VPN (OpenVPN) и телефония (SIPoTLS). Он обеспечивает шифрование (симметричным ключом), авторизацию (PKI), проверку целостности переданной информации (HMAC). Важная часть TLS - PKI (инфраструктура публичных ключей). Любой публичный ключ в TLS должен быть подписан (публичный ключ с подписью и набором определенных атрибутов называется сертификатом). Центр сертификации – критически важная часть работы TLS, так как он управляет доверием к приложению или сервису (цепочки доверия). В этой статье я расскажу о том, как запустить свой собственный CA на основе CFSSL. Введение получилось неожиданно большим, так что если вам нужна практика - вам сюда&lt;/p>
&lt;h2 id="цепочки-доверия" >
&lt;div>
&lt;a href="#%d1%86%d0%b5%d0%bf%d0%be%d1%87%d0%ba%d0%b8-%d0%b4%d0%be%d0%b2%d0%b5%d1%80%d0%b8%d1%8f">
#
&lt;/a>
Цепочки доверия
&lt;/div>
&lt;/h2>
&lt;p>В ассиметричном шифровании каждый сервис имеет два ключа, открытый (публичный) и закрытый (приватный). Из приватного ключа можно легко получить публичный, но обратная операция практически невозможна. Из публичного ключа, добавив в него несколько текстовых полей (атрибутов) - можно создать запрос на сертификат (CSR). Центр сертификации подписывает CSR и таким образом CSR становится сертификатом. Подписью центр сертификации (CA) подтверждает, что:&lt;/p>
&lt;ul>
&lt;li>сервис, использующий этот сертификат – достоин доверия с точки зрения CA&lt;/li>
&lt;li>цифровая подпись действительна в определенный момент времени (у нее есть ограничения по сроку жизни)&lt;/li>
&lt;li>подписанный CA сертификат можно использовать определенным образом. Возможности использования описаны атрибутами в сертификате. Так, как атрибуты подписываются вместе с самим публичным ключом – их нельзя поменять, это разрушит цифровую подпись.&lt;/li>
&lt;/ul>
&lt;p>Сертификат может быть отозван по определенной причине (например, приватный ключ сервиса был украден). Для того, чтобы приложения (пользователи) узнали о факте отзыва – существует CRL (certificate revocation list). Устроен он сравнительно просто: это текстовый файл, где перечислены уникальные серийные номера сертификатов (SSN) и дата отзыва. Содержимое файла подписано цифровой подписью CA, что исключает подделку.&lt;/p>
&lt;p>Чтобы клиент (приложение) мог доверять центру сертификации – у него должен быть сертификат центра сертификации. Этому сертификату клиент (приложение) доверяет безусловно, а используя этот сертификат – может проверить цельность цифровой подписи любого сертификата, подписанного доверенным центром сертификации.&lt;/p>
&lt;p>Очевидно, что потеря (компрометация) ключа доверенного центра сертификации – это крайне плохо – нужно создать новый ключ после чего заново подписать все сертификаты. Плюс – разослать всем клиентам новый сертификат, а старый пометить, как не подлежащий доверию. Тот, кто украдет ключ центра сертификации – сможет выписывать себе произвольные сертификаты и соединение с таким сервисом будет считаться совершенно безопасным.&lt;/p>
&lt;p>Чтобы избежать этого – IEEE придумали цепочки сертификатов. Сначала создается “корневая пара” из приватного ключа и сертификата. Именно этому сертификату будут доверять клиенты безусловно. Корневой сертификат подписывает сам себе. Затем создается “промежуточная пара”. Ключ промежуточной пары подписывается корневым ключом. Теперь корневой ключ можно положить сейф, залить сейф бетоном и закопать в основании небоскреба – в обозримом будущем он нам не потребуется. Клиентские сертификаты будут подписаны промежуточной парой. Клиент, подключаясь, проверит, что сертификат подписан промежуточным центром сертификации, а сертификат промежуточного центра подписан сертификатом, которому клиент доверяет. Такая конструкция называется цепочкой доверия или цепочкой сертификатов (certificate chain), а обладатель промежуточной пары – промежуточным центром сертификации (intermediate center of authorities). Если произойдет ужасное, и ключ промежуточного центра утечет – мы просто откопаем сейф, вынем из него корневой ключ, подпишем этим ключом новую корневую пару и будем подписывать новые сертификаты уже новой корневой парой. Сертификаты, подписанные скомпрометированным ключом – придется перевыпускать (то есть – подписать заново, новым ключом), но хотя бы не придется заставлять всех клиентов менять рутовый сертификат.&lt;/p>
&lt;h2 id="что-делает-ca-и-из-чего-его-можно-собрать" >
&lt;div>
&lt;a href="#%d1%87%d1%82%d0%be-%d0%b4%d0%b5%d0%bb%d0%b0%d0%b5%d1%82-ca-%d0%b8-%d0%b8%d0%b7-%d1%87%d0%b5%d0%b3%d0%be-%d0%b5%d0%b3%d0%be-%d0%bc%d0%be%d0%b6%d0%bd%d0%be-%d1%81%d0%be%d0%b1%d1%80%d0%b0%d1%82%d1%8c">
#
&lt;/a>
Что делает CA и из чего его можно собрать
&lt;/div>
&lt;/h2>
&lt;p>Как я уже говорил выше – CA - это пара “приватный ключ + публичный ключ”, в котором приватный ключ создает для сертификатов цифровые подписи. Доступный всем желающим публичный ключ можно использовать для проверки цифровой подписи. При подписании СА должен внести в сертификат уникальный серийный номер подписанного сертификата, а так же – указать срок действия подписи. Хороший центр сертификации должен вести учет выданных сертификатов (то есть - хранить серийные номера всех сертификатов, которые он подписал), а так же – при необходимости создавать CRL – список отозванных сертификатов. Так как TLS сейчас буквально везде – способов создать CA существует множество:&lt;/p>
&lt;h3 id="openssl-ca" >
&lt;div>
&lt;a href="#openssl-ca">
##
&lt;/a>
OpenSSL ca
&lt;/div>
&lt;/h3>
&lt;p>OpenSSL - это классика реализации SSL (TLS) в xNIX. Состоит из библиотеки (libssl) и утилиты командной строки (openssl). Штука фантастически, невероятно, исключительно сложная. Алгоритмы криптографии в принципе не подарок, а в случае openssl сложнейший С-код набит различными оптимизациями для ускорения работы (шифрование должно работать быстро!). Плюс OpenSSL поддерживается для кучи различных платформ (ОС и процессоров). Ориентация в коде OpenSSL – сложнейшее дело. В 2014 году небольшая правка в коде вызывала уязвимость, известную как “heartbleed” – отправляя специально сформированные пакеты на любой сервис, использующий TLS - можно было читать память, доступную процессу, принимающему пакеты. Чтение было медленным, но результат – сокрушительным: heartbleed позволял вытаскивать внутренние данные работающих программ, читать данные других пользователей, даже воровать приватные ключи приложения.&lt;/p>
&lt;p>Пользовательская сторона OpenSSL тоже не подарок – умеет она много, а документирована при этом просто отвратительно. Достаточно просто сказать, что список только доступных команд к утилите openssl - это 3 страницы текста. А руководства, в общем-то – нет. В случае работы с OpenSSL очень несложно сделать ошибку, из-за которой ваш CA станет небезопасным, а потому я не рекомендую использовать openssl для этого.&lt;/p>
&lt;h3 id="easyrsa--easyrsav2" >
&lt;div>
&lt;a href="#easyrsa--easyrsav2">
##
&lt;/a>
EasyRSA / EasyRSAv2
&lt;/div>
&lt;/h3>
&lt;p>По сути это вообще не утилита. Это набор shell-скриптов, которые используют все тот же OpenSSL. Это резко облегчает настройку и снижает вероятность ошибки, но – уменьшает гибкость настройки. Плюс скрипты могут ломаться (у них бывает, увы), и в таком случае вам будет очень трудно понять, что именно у вас сломалось, и где. Ибо за милым и простым фасадом из easy-rsa вас ждет кровожадное лицо OpenSSL.&lt;/p>
&lt;h3 id="hasicorp-vault" >
&lt;div>
&lt;a href="#hasicorp-vault">
##
&lt;/a>
Hasicorp Vault
&lt;/div>
&lt;/h3>
&lt;p>Мощная, удобная утилита для создания и хранения секретов. Секретов самых разных - паролей, токенов. Умеет работать с центрами сертификации в том числе. Прекрасный выбор, если вам нужно построить большую и сложную систему централизованного управления секретами и давать в эту систему ограниченный доступ. Для новичка – очень сложно. Требует поднятия отдельного сервера (где будет работать сервис vault), поднятия отдельного хранилища данных, написания политик доступа в vault. Если вам нужно быстро запустить CA (или несколько, но работать с самим СА будет буквально пара человек) - это явный перебор&lt;/p>
&lt;h3 id="cfssl" >
&lt;div>
&lt;a href="#cfssl">
##
&lt;/a>
CFSSL
&lt;/div>
&lt;/h3>
&lt;p>То, ради чего статья затевалась. Набор из простых, небольших, понятных утилит для создания и управления CA. Код написан целиком на golang – он простой и легко читается. Так как утилита сравнительно молодая - в ней минимум legacy-кода. Изначально написана и поддерживается компанией CloudFlare - огромным CDN-провайдером. Так как CF активно использует шифрование внутри своей сети – сертификатов ему нужно море, по этому они и написали собственный инструментарий для работы с ними&lt;/p>
&lt;h2 id="самый-простой-случай-bare-ca" >
&lt;div>
&lt;a href="#%d1%81%d0%b0%d0%bc%d1%8b%d0%b9-%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be%d0%b9-%d1%81%d0%bb%d1%83%d1%87%d0%b0%d0%b9-bare-ca">
#
&lt;/a>
Самый простой случай: Bare CA
&lt;/div>
&lt;/h2>
&lt;p>Чтобы установить свежую версию cfssl (если у вас нет ее в пакетах) – потребуется go версии 1.10 или выше. Ставим:&lt;/p>
&lt;pre>&lt;code>go get -u github.com/cloudflare/cfssl/cmd/cfssl
&lt;/code>&lt;/pre>
&lt;p>Проверяем установку:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl version
Version: 1.3.2
Revision: dev
Runtime: go1.10.2
&lt;/code>&lt;/pre>
&lt;p>Все ок, можно делать CA. Создаем папку для CA, переходим туда и создаем конфиг для создания ключа самого CA:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;Test Root CA&amp;quot;,
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
&amp;quot;size&amp;quot;: 2048
},
&amp;quot;ca&amp;quot;: {
&amp;quot;expiry&amp;quot;: &amp;quot;87600h&amp;quot;
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;RU&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;Saint Petersburg&amp;quot;,
&amp;quot;O&amp;quot;: &amp;quot;Test Company&amp;quot;,
&amp;quot;OU&amp;quot;: &amp;quot;Internal systems unit&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;Saint Petersburg&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;p>В данном примере мы используем ключ RSA в 2048 бит размером. CFSSL поддерживает как RSA таки ECDSA ключи. Назовем файлик csr.json. Поле expiry задает срок жизни CA. CA не может подписывать ключ на срок больший его собственной жизни. Точнее – может, но смысла в этом нет – когда срок существования цифровой подписи самого CA закончится – все созданные им цифровые подписи не будут считаться легитимными.&lt;/p>
&lt;p>Сгенерируем ключ:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl gencert -initca csr.json | cfssljson -bare ca
2018/12/14 19:56:56 [INFO] generating a new CA key and certificate from CSR
2018/12/14 19:56:56 [INFO] generate received request
2018/12/14 19:56:56 [INFO] received CSR
2018/12/14 19:56:56 [INFO] generating key: rsa-2048
2018/12/14 19:56:57 [INFO] encoded CSR
2018/12/14 19:56:57 [INFO] signed certificate with serial number 594378542753634129370457275219291351654652931156
&lt;/code>&lt;/pre>
&lt;p>Посмотрим в папку:&lt;/p>
&lt;pre>&lt;code>&amp;gt; tree
.
├── csr.json
├── ca-key.pem
├── ca.csr
└── ca.pem
0 directories, 4 files
&lt;/code>&lt;/pre>
&lt;p>Где:&lt;/p>
&lt;ul>
&lt;li>ca-key.pem - приватный ключ, которым подписываются сертификаты&lt;/li>
&lt;li>ca.pem - сам сертификат&lt;/li>
&lt;li>ca.csr - запрос на сертификат (публичный ключ без подписи).&lt;/li>
&lt;/ul>
&lt;p>Лично я рекомендую для общего удобства работы ключи класть в отдельную папку, ее можно, к примеру, назвать keys:&lt;/p>
&lt;pre>&lt;code>mkdir keys
mv ca-key.pem ca.csr ca.pem keys/
&lt;/code>&lt;/pre>
&lt;p>Чтобы в Теперь создадим конфиг для создания клиентских ключей и сертификатов. Назовем его, например, ca.json:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;signing&amp;quot;: {
&amp;quot;profiles&amp;quot;: {
&amp;quot;server&amp;quot;: {
&amp;quot;expiry&amp;quot;: &amp;quot;17520h&amp;quot;,
&amp;quot;usages&amp;quot;: [
&amp;quot;digital signature&amp;quot;,
&amp;quot;key encipherment&amp;quot;,
&amp;quot;server auth&amp;quot;
]
},
&amp;quot;client&amp;quot;: {
&amp;quot;expiry&amp;quot;: &amp;quot;8760h&amp;quot;,
&amp;quot;usages&amp;quot;: [
&amp;quot;signing&amp;quot;,
&amp;quot;client auth&amp;quot;
]
}
}
}
}
&lt;/code>&lt;/pre>
&lt;p>В этом примере у нас два профиля – сертификаты для сервера (со сроком жизни в 2 года) и для клиента (на год). Сертификат клиента может использоваться для авторизации клиентского подключения (например, в OpenVPN), но такой сертификат нельзя выдать серверу.&lt;/p>
&lt;p>Чтобы мочь использовать конфиг для CSR (и не вводить заново страну, регион и прочее) – его нужно подправить, убрав из него секцию CA:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;Test Root CA&amp;quot;,
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;rsa&amp;quot;,
&amp;quot;size&amp;quot;: 2048
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;RU&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;Saint Petersburg&amp;quot;,
&amp;quot;O&amp;quot;: &amp;quot;Test Company&amp;quot;,
&amp;quot;OU&amp;quot;: &amp;quot;Internal systems unit&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;Saint Petersburg&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;p>Теперь сгенерируем серверный ключ:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl gencert -ca=keys/ca.pem \
-ca-key=keys/ca-key.pem \
-config=ca.json \
-profile=&amp;quot;server&amp;quot; \
-cn=&amp;quot;test.server.local&amp;quot; \
-hostname=&amp;quot;test.server.local,test,192.168.1.1&amp;quot; \
csr.json | cfssljson -bare keys/server
2018/12/14 20:28:47 [INFO] generate received request
2018/12/14 20:28:47 [INFO] received CSR
2018/12/14 20:28:47 [INFO] generating key: rsa-2048
2018/12/14 20:28:48 [INFO] encoded CSR
2018/12/14 20:28:48 [INFO] signed certificate with serial number 53158698715503305792227475745544378560981646495
&lt;/code>&lt;/pre>
&lt;p>Аргумент cfssljson -bare keys/server позволяет положить ключ в папку keys, и называться файлы будут с server&lt;/p>
&lt;p>Посмотрим, что получилось:&lt;/p>
&lt;pre>&lt;code>&amp;gt; tree
.
├── ca.json
├── csr.json
└── keys
├── ca-key.pem
├── ca.csr
├── ca.pem
├── server-key.pem
├── server.csr
└── server.pem
&lt;/code>&lt;/pre>
&lt;p>Проверим ключ сервера:&lt;/p>
&lt;pre>&lt;code>&amp;gt; openssl x509 -text -noout -in keys/server.pem
Certificate:
Data:
Version: 3 (0x2)
Serial Number:
09:4f:b7:ef:17:c4:b5:f5:06:f6:66:bb:0f:85:de:f0:b6:8a:3c:9f
Signature Algorithm: sha256WithRSAEncryption
Issuer: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=Test Root CA
Validity
Not Before: Dec 14 17:24:00 2018 GMT
Not After : Dec 13 17:24:00 2020 GMT
Subject: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=test.server.local
Subject Public Key Info:
Public Key Algorithm: rsaEncryption
Public-Key: (2048 bit)
&lt;/code>&lt;/pre>
&lt;p>Теперь создадим сертификат для клиента (скажем, для OpenVPN):&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl gencert -ca=keys/ca.pem \
-ca-key=keys/ca-key.pem \
-config=ca.json \
-profile=&amp;quot;client&amp;quot; \
-cn=&amp;quot;prudnitskiy&amp;quot; \
-hostname=&amp;quot;Paul Rudnitskiy&amp;quot; \
csr.json | cfssljson -bare &amp;quot;keys/prudnitskiy&amp;quot;
2018/12/14 20:35:56 [INFO] generate received request
2018/12/14 20:35:56 [INFO] received CSR
2018/12/14 20:35:56 [INFO] generating key: rsa-2048
2018/12/14 20:35:57 [INFO] encoded CSR
2018/12/14 20:35:57 [INFO] signed certificate with serial number 82476622684473156560886280203356252095924099426
&lt;/code>&lt;/pre>
&lt;p>Проверим сертификат клиента:&lt;/p>
&lt;pre>&lt;code>&amp;gt; openssl x509 -text -noout -in keys/prudnitskiy.pem
Certificate:
Data:
Version: 3 (0x2)
Serial Number:
0e:72:61:32:19:eb:71:30:43:ee:66:6d:8d:8c:e7:e5:bd:57:59:62
Signature Algorithm: sha256WithRSAEncryption
Issuer: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=Test Root CA
Validity
Not Before: Dec 14 17:31:00 2018 GMT
Not After : Dec 14 17:31:00 2019 GMT
Subject: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=prudnitskiy
Subject Public Key Info:
Public Key Algorithm: rsaEncryption
Public-Key: (2048 bit)
[.....]
X509v3 Subject Alternative Name:
DNS:Paul Rudnitskiy
&lt;/code>&lt;/pre>
&lt;p>Здесь видно, что у клиента сертификат на год, а у сервера (чуть выше) - на два года&lt;/p>
&lt;h2 id="подпись-чужого-сертификата" >
&lt;div>
&lt;a href="#%d0%bf%d0%be%d0%b4%d0%bf%d0%b8%d1%81%d1%8c-%d1%87%d1%83%d0%b6%d0%be%d0%b3%d0%be-%d1%81%d0%b5%d1%80%d1%82%d0%b8%d1%84%d0%b8%d0%ba%d0%b0%d1%82%d0%b0">
#
&lt;/a>
Подпись чужого сертификата
&lt;/div>
&lt;/h2>
&lt;p>В примере выше мы создавали и ключ и сертификат прямо там, где работает центр сертификации. Вообще это не правильно – приватный ключ не должен покидать места своего использования. В этом примере мы создадим приватный ключ, запрос на подпись сертификата и подпишем этот запрос на другом сервере. Создаем ключ:&lt;/p>
&lt;pre>&lt;code>server$ openssl genrsa -aes256 -out client.key 4096
Generating RSA private key, 4096 bit long modulus
...................................................++
................................................................................................................................................................................++
e is 65537 (0x10001)
Enter pass phrase for client.key:
Verifying - Enter pass phrase for client.key:
&lt;/code>&lt;/pre>
&lt;p>Теперь создаем запрос на сертификат:&lt;/p>
&lt;pre>&lt;code>server$ openssl req -new -key client.key -out client.csr
Enter pass phrase for client.key:
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:RU
State or Province Name (full name) [Some-State]:Saint Petersburg
Locality Name (eg, city) []:Saint Petersburg
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Test Company
Organizational Unit Name (eg, section) []:International section
Common Name (e.g. server FQDN or YOUR name) []:test2.ssign.local
Email Address []:
Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:
An optional company name []:
&lt;/code>&lt;/pre>
&lt;p>У нас есть приватный ключ и запрос на сертификат:&lt;/p>
&lt;pre>&lt;code>server$ tree
.
├── client.csr
└── client.key
&lt;/code>&lt;/pre>
&lt;p>Запрос отправим на сервер и подпишем:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl sign -ca keys/ca.pem \
-ca-key keys/ca-key.pem \
-config=ca.json \
-profile=&amp;quot;server&amp;quot; \
client.csr | cfssljson -bare &amp;quot;keys/signed&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Проверим, что получилось:&lt;/p>
&lt;pre>&lt;code>&amp;gt; openssl x509 -text -noout -in keys/signed.pem
Certificate:
Data:
Version: 3 (0x2)
Serial Number:
06:08:a0:e6:77:a0:a3:f2:15:82:6c:8a:da:9c:9a:73:df:a4:aa:5c
Signature Algorithm: sha256WithRSAEncryption
Issuer: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=Test Root CA
Validity
Not Before: Dec 14 17:45:00 2018 GMT
Not After : Dec 13 17:45:00 2020 GMT
Subject: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=International section, CN=test2.ssign.local
Subject Public Key Info:
Public Key Algorithm: rsaEncryption
Public-Key: (4096 bit)
&lt;/code>&lt;/pre>
&lt;p>keys/signed.pem – это и есть наш подписанный сертификат – его можно возвращать на сервер и использовать.&lt;/p>
&lt;h2 id="intermediate-center-of-authorities" >
&lt;div>
&lt;a href="#intermediate-center-of-authorities">
#
&lt;/a>
Intermediate center of authorities
&lt;/div>
&lt;/h2>
&lt;p>InterimCA - это центр сертификации, подписанный другим центром сертификации. Его можно использовать для большей безопасности или разграничения возможности подписывать разные сертификаты для разных ситуаций (например, сделать CA, который подписывает только соединение с базами данных и ничего более). Сделаем для его отдельную папку и положим туда два конфига:&lt;/p>
&lt;p>l2init.json:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;signing&amp;quot;: {
&amp;quot;default&amp;quot;: {
&amp;quot;usages&amp;quot;: [
&amp;quot;cert sign&amp;quot;,
&amp;quot;crl sign&amp;quot;
],
&amp;quot;expiry&amp;quot;: &amp;quot;43800h&amp;quot;,
&amp;quot;ca_constraint&amp;quot;: {
&amp;quot;is_ca&amp;quot;: true,
&amp;quot;max_path_len&amp;quot;: 0,
&amp;quot;max_path_len_zero&amp;quot;: true
},
&amp;quot;crl_url&amp;quot;: &amp;quot;https://server.com/pki/crl&amp;quot;
}
}
}
&lt;/code>&lt;/pre>
&lt;p>В этом примере CA будет действовать 5 лет (root CA действует 10)&lt;/p>
&lt;p>l2csr.json:&lt;/p>
&lt;pre>&lt;code>{
&amp;quot;CN&amp;quot;: &amp;quot;Level2 CA&amp;quot;,
&amp;quot;key&amp;quot;: {
&amp;quot;algo&amp;quot;: &amp;quot;ecdsa&amp;quot;,
&amp;quot;size&amp;quot;: 384
},
&amp;quot;names&amp;quot;: [
{
&amp;quot;C&amp;quot;: &amp;quot;RU&amp;quot;,
&amp;quot;L&amp;quot;: &amp;quot;Saint Petersburg&amp;quot;,
&amp;quot;O&amp;quot;: &amp;quot;Test Company&amp;quot;,
&amp;quot;OU&amp;quot;: &amp;quot;Internal systems unit&amp;quot;,
&amp;quot;ST&amp;quot;: &amp;quot;Saint Petersburg&amp;quot;
}
]
}
&lt;/code>&lt;/pre>
&lt;p>В этом примере мы используем ключ на эллиптических кривых, 384 бита&lt;/p>
&lt;p>Сгенерируем ключ для L2CA:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl gencert -initca l2/l2csr.json | cfssljson -bare &amp;quot;l2/l2ca&amp;quot;
2018/12/14 21:09:11 [INFO] generating a new CA key and certificate from CSR
2018/12/14 21:09:11 [INFO] generate received request
2018/12/14 21:09:11 [INFO] received CSR
2018/12/14 21:09:11 [INFO] generating key: ecdsa-384
2018/12/14 21:09:11 [INFO] encoded CSR
2018/12/14 21:09:11 [INFO] signed certificate with serial number 113401202328445156746253039479389987233218778440
&lt;/code>&lt;/pre>
&lt;p>Теперь подпишем его ключом Root CA:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl sign -ca keys/ca.pem \
-ca-key keys/ca-key.pem \
-config=l2/l2init.json l2/l2ca.csr | cfssljson -bare &amp;quot;l2/l2ca&amp;quot;
2018/12/14 21:09:21 [INFO] signed certificate with serial number 716266849684210842961608276575977912635137621329
&lt;/code>&lt;/pre>
&lt;p>Проверим:&lt;/p>
&lt;pre>&lt;code>&amp;gt; openssl x509 -text -noout -in l2/l2ca.pem
Certificate:
Data:
Version: 3 (0x2)
Serial Number:
7d:76:84:30:b6:71:47:f6:51:0a:f1:40:4d:26:86:21:0c:da:7d:51
Signature Algorithm: sha256WithRSAEncryption
Issuer: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=Test Root CA
Validity
Not Before: Dec 14 18:04:00 2018 GMT
Not After : Dec 13 18:04:00 2023 GMT
Subject: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=Level2 CA
&lt;/code>&lt;/pre>
&lt;p>Здесь хорошо видно, что ключ подписан Test Root CA (Issuer)&lt;/p>
&lt;p>Теперь можно создавать ключи, подписаные L2CA - как в прошлом примере:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cfssl gencert -ca=l2/l2ca.pem \
-ca-key=l2/l2ca-key.pem \
-config=ca.json \
-profile=&amp;quot;server&amp;quot; \
-cn=&amp;quot;test.l2.server.local&amp;quot; \
-hostname=&amp;quot;test.l2.server.localtest,172.16.0.1&amp;quot; \
l2/l2csr.json | cfssljson -bare l2/server
&lt;/code>&lt;/pre>
&lt;p>Здесь мы используем ca.json из root ca (там хранятся профили подписи - время жизни и key usage), а конфигурацию CSR - уже из L2 (тип ключа, секция names).&lt;/p>
&lt;p>Проверим сгенерированый сертификат:&lt;/p>
&lt;pre>&lt;code>&amp;gt; openssl x509 -text -noout -in l2/server.pem
Certificate:
Data:
Version: 3 (0x2)
Serial Number:
30:a0:58:e2:3c:0e:f3:ec:73:64:b0:e1:25:0a:86:26:46:43:21:e2
Signature Algorithm: ecdsa-with-SHA384
Issuer: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=Level2 CA
Validity
Not Before: Dec 14 18:11:00 2018 GMT
Not After : Dec 13 18:11:00 2020 GMT
Subject: C=RU, ST=Saint Petersburg, L=Saint Petersburg, O=Test Company, OU=Internal systems unit, CN=test.l2.server.local
&lt;/code>&lt;/pre>
&lt;p>Подписант – Level2CA&lt;/p>
&lt;p>Создадим цепочку доверенных сертификатов. Цепочка читается “снизу вверх”, то есть в самом низу цепочки у нас находится root CA:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cat l2/l2ca.pem keys/ca.pem &amp;gt; chain.pem
&lt;/code>&lt;/pre>
&lt;p>Проверим, что сертификат сервера - действительный:&lt;/p>
&lt;pre>&lt;code>&amp;gt; openssl verify -CAfile chain.pem l2/server.pem
l2/server.pem: OK
&lt;/code>&lt;/pre>
&lt;h2 id="выводы" >
&lt;div>
&lt;a href="#%d0%b2%d1%8b%d0%b2%d0%be%d0%b4%d1%8b">
#
&lt;/a>
Выводы
&lt;/div>
&lt;/h2>
&lt;p>TLS - основа современной сети. При правильной настройке TLS обеспечивает надежную и безопасное шифрование с проверкой всех участников процесса. CFSSL – простой, быстрый и удобный инструмент для запуска SSL CA. Он позволяет избежать само-подписанных сертификатов и помогает построить инфраструктуру обмена ключами для шифрованных соединений. Так, как большинство серверов работает в сети, которой по определению нельзя доверять – использовать шифрование необходимо, а благодаря CFSSL – это несложно.&lt;/p></description></item><item><title>Yubikey + GPG – быстрый старт</title><link>/ru/post/2018-08-02-yubikey-gpg/</link><pubDate>Thu, 02 Aug 2018 09:00:00 +0000</pubDate><guid>/ru/post/2018-08-02-yubikey-gpg/</guid><description>&lt;p>Требования к безопасности непрерывно растут, так как взломщики постоянно эволюционируют и все лучше умеют красть данные. Доступ к данным становится все более ценным - это могут быть живые деньги, секретная информация или доступ в инфраструктуру, интеллектуальную собственность или пользовательские данные (которые эта инфраструктура обрабатывает). А это – очень большие деньги. А иногда и вовсе вопрос жизни и смерти целой структуры.&lt;/p>
&lt;p>Простой системы логин/пароль уже недостаточно, чтобы обеспечить надежную защиту, и даже система с ассиметричными ключами имеет уязвимости:&lt;/p>
&lt;ul>
&lt;li>ключ можно выкрасть. Он будет шифрован, но пароль можно подобрать. Это медленный процесс, но взломщику может повезти, особенно, если у него есть какая-то информация об особенностях пароля. Например, он знает его точную длинну.&lt;/li>
&lt;li>Для того, чтобы ключ можно было использовать - он должен быть расшифрован. Обычно расшифрованый ключ хранится в оперативной памяти, но при наличии доступа к памяти его можно украсть. Атака сложная, но если ключ по-настоящиему ценный - реальная.&lt;/li>
&lt;/ul>
&lt;p>Для того, чтобы сделать работу с шифрованием надежной и безопасной – были придуманы аппаратные носители ключей. Концепция выглядит просто – шифровальный ключ не покидает аппаратного токена (обычно это смарт-карта с чипом), и если операционной системе требуется произвести какое-то действие с шифрованием (зашифровка, расшифровка, подпись) – данные передаются в аппаратный ключ. Ключ выполняет действия (если проситель имеет право на такие действия) и выдает результат.&lt;/p>
&lt;p>В этой статье я расскажу, как настроить Yubikey 4 для работы с GPG и использовать его для стандартных действий (шифрование, расшифровка, авторизация по SSH).&lt;/p>
&lt;p>Yubikey - это именно такой ключ. Это простой, удобный и понятный для начинающего ключ-смарткарта в форм-факторе USB-флешки. Классический Yubikey 4 выпускается в двух форм-факторах – обычная &amp;ldquo;полноразмерная&amp;rdquo; флешка или &amp;ldquo;нано-ключ&amp;rdquo; - вставленный в комп наноключ практически не выступает из порта, что удобно, если ключ подключен постоянно и не должен изыматься. Yubikey 4 выпускается как под USB2 Type A, так и под USB3 Type C порт, что удобно для обладателей новых ноутбуков (macbook pro touch bar). Так же компания Yubiko выпускает Yubkey Neo - Yubkey с поддержкой NFC (для смартфонов), но со сниженным максимальным размером ключа (2048 бит вместо 4096 для Yubikey 4).&lt;/p>
&lt;p>Кроме GPG, Yubikey может работать как стандартная smart-карта и генерировать одноразовые пароли (TOTP/HOTP). В этой статье будет описана только настройка под GPG.&lt;/p>
&lt;h2 id="предварительные-настройки" >
&lt;div>
&lt;a href="#%d0%bf%d1%80%d0%b5%d0%b4%d0%b2%d0%b0%d1%80%d0%b8%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b8">
#
&lt;/a>
Предварительные настройки
&lt;/div>
&lt;/h2>
&lt;p>Для того, чтобы использовать gpg для Yubikey - потребуется сам gpg. Пользователи MacOS могут использовать &lt;a href="https://gpgtools.org/">MacGPG&lt;/a>. Пользователям Linux ничего делать не надо - gpg входит в поставку ОС. Чтобы gpg создал нужные ему папки - запускаем gpgtool. Он предложит создать новый приватный ключ - игнорируем, просто закрываем программу.&lt;/p>
&lt;p>После установки пакета надо добавить в &lt;code>~/.bashrc&lt;/code> следующие строки:&lt;/p>
&lt;pre>&lt;code>export GPG_TTY=&amp;quot;$(tty)&amp;quot;
export SSH_AUTH_SOCK=$(/usr/local/MacGPG2/bin/gpgconf --list-dirs agent-ssh-socket)
if ! pgrep gpg-agent &amp;amp;&amp;gt; /dev/null; then
echo &amp;quot;gpg-agent not running&amp;quot;
/usr/local/MacGPG2/bin/gpg-agent --homedir /Users/YOUR_LOGIN/.gnupg --daemon
fi
&lt;/code>&lt;/pre>
&lt;p>Обратите внимание, что вам нужно поменять логин на свой&lt;/p>
&lt;p>Также надо указать pinentry и включить поддежку ssh-agent в файле &lt;code>~/.gnupg/gpg-agent.conf&lt;/code>:&lt;/p>
&lt;pre>&lt;code>default-cache-ttl 600
max-cache-ttl 7200
pinentry-program /usr/local/MacGPG2/libexec/pinentry-mac.app/Contents/MacOS/pinentry-mac
enable-ssh-support
&lt;/code>&lt;/pre>
&lt;p>Теперь можно подключить yubikey. Проверим, что карта подключилась и определилась:&lt;/p>
&lt;pre>&lt;code>tungsten&amp;gt; gpg --card-edit
Reader ...........: Yubico Yubikey 4 OTP U2F CCID
Application ID ...: D2760001240102010006070171690000
Version ..........: 2.1
Manufacturer .....: Yubico
Serial number ....: 07017169
Name of cardholder: [not set]
Language prefs ...: [not set]
Sex ..............: unspecified
URL of public key : [not set]
Login data .......: [not set]
Signature PIN ....: not forced
Key attributes ...: rsa2048 rsa2048 rsa2048
Max. PIN lengths .: 127 127 127
PIN retry counter : 3 0 3
Signature counter : 0
Signature key ....: [none]
Encryption key....: [none]
Authentication key: [none]
General key info..: [none]
gpg/card&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Отлично, карта есть, можно настраивать. Первое, что нужно поменять - pin-коды карты. У карты два pin-кода:&lt;/p>
&lt;ul>
&lt;li>User PIN - отвечает за проверку авторизации самой карты. Его нужно ввести, чтобы использовать ключ (зашифровать, расшифровать данные или авторизоваться)&lt;/li>
&lt;li>Admin PIN - отвечает за настройку карты. Он позволяет управлять содержимым карты или ее настройками.&lt;/li>
&lt;/ul>
&lt;p>Не смотря на названия, PIN-коды - это полноценные пароли длинной до 127 символов включительно. Пароли имеют ограничения - там нельзя использовать символы национальных алфавитов и спецсимволы. То есть – можно только английские буквы и цифры. Кроме того, Admin PIN должен быть не менее 8 символов длинной. Yubikey никак не предупредит об этом, но pin короче 8 символов просто не запишется. При смене PIN-кода спросят старый PIN. PIN-коды по умолчанию:&lt;/p>
&lt;ul>
&lt;li>User PIN: 123456&lt;/li>
&lt;li>Admin PIN: 12345678&lt;/li>
&lt;/ul>
&lt;p>Переключимся в админ-режим и поменяем пины:&lt;/p>
&lt;pre>&lt;code>gpg/card&amp;gt; admin
Admin commands are allowed
gpg/card&amp;gt; passwd
gpg: OpenPGP card no. D2760001240102010006070171690000 detected
1 - change PIN
2 - unblock PIN
3 - change Admin PIN
4 - set the Reset Code
Q - quit
Your selection? 1
PIN changed.
1 - change PIN
2 - unblock PIN
3 - change Admin PIN
4 - set the Reset Code
Q - quit
Your selection? 3
PIN changed.
1 - change PIN
2 - unblock PIN
3 - change Admin PIN
4 - set the Reset Code
Q - quit
Your selection? q
&lt;/code>&lt;/pre>
&lt;p>Небольшая ремарка про PIN-ы. Карта считает все неуспешные попытки использования PIN-кода. Если ввести PIN-код неправильно несколько раз подряд – он блокируется. User PIN можно разблокировать с помощью Admin PIN. Заблокированный Admin PIN разблокировать нельзя никак. Карту можно полностью сбросить командой &lt;code>factory-reset&lt;/code> - при этом все ее содержимое будет безвозвратно уничтожено. Для &lt;code>factory-reset&lt;/code> никакие пин-коды не нужны. Счетчик неуспешных попыток сбрасывается, если ввести PIN правильно.&lt;/p>
&lt;p>Теперь рекомендуется персонализировать карту - внести в нее информацию о себе. Это мало на что влияет, но имя будет отображаться в диалоге ввода PIN (что облегчает идентификацию карты). Кроме того, общую информацию о карте можно прочитать без кода – это может помочь, если вы потеряете карту. Важный параметр - url, это адрес, с которого можно будет скачать ваш &lt;strong>публичный&lt;/strong> ключ:&lt;/p>
&lt;pre>&lt;code>gpg/card&amp;gt; name
Cardholder's surname: Rudnitskiy
Cardholder's given name: Paul
gpg/card&amp;gt; sex
Sex ((M)ale, (F)emale or space): M
gpg/card&amp;gt; lang
Language preferences: en
gpg/card&amp;gt; login
Login data (account name): logan
gpg/card&amp;gt; url
URL to retrieve public key: https://prudnitskiy.pro/gpg.pub
&lt;/code>&lt;/pre>
&lt;p>Карта готова и теперь можно экспортировать ключ на нее или создать ключ прямо на ней. Если у вас нет ключа - я рекомендую прямо на карте его и создавать. Если ключ уже есть – ниже есть раздел о том, как перенести ключ на карту&lt;/p>
&lt;h2 id="генерация-ключа-на-yubikey" >
&lt;div>
&lt;a href="#%d0%b3%d0%b5%d0%bd%d0%b5%d1%80%d0%b0%d1%86%d0%b8%d1%8f-%d0%ba%d0%bb%d1%8e%d1%87%d0%b0-%d0%bd%d0%b0-yubikey">
#
&lt;/a>
Генерация ключа на Yubikey
&lt;/div>
&lt;/h2>
&lt;p>Перед тем, как создавать ключ - я рекомендую поменять его размер. По умолчанию Yubikey создает один мастер-ключ и два сабключа:&lt;/p>
&lt;ul>
&lt;li>Master + Certify&lt;/li>
&lt;li>SUB1 - Encryption&lt;/li>
&lt;li>SUB2 – Authentication&lt;/li>
&lt;/ul>
&lt;p>Все три ключа по умолчанию - RSA2048. RSA4096 выглядит намного интереснее. Поменяем:&lt;/p>
&lt;pre>&lt;code>gpg/card&amp;gt; key-attr
Changing card key attribute for: Signature key
Please select what kind of key you want:
(1) RSA
(2) ECC
Your selection? 1
What keysize do you want? (2048) 4096
The card will now be re-configured to generate a key of 4096 bits
Changing card key attribute for: Encryption key
Please select what kind of key you want:
(1) RSA
(2) ECC
Your selection? 1
What keysize do you want? (2048) 4096
The card will now be re-configured to generate a key of 4096 bits
Changing card key attribute for: Authentication key
Please select what kind of key you want:
(1) RSA
(2) ECC
Your selection? 1
What keysize do you want? (2048) 4096
The card will now be re-configured to generate a key of 4096 bits
gpg: error changing key attribute for key 3: Bad PIN
Changing card key attribute for: Authentication key
Please select what kind of key you want:
(1) RSA
(2) ECC
Your selection? 1
What keysize do you want? (2048) 4096
The card will now be re-configured to generate a key of 4096 bits
&lt;/code>&lt;/pre>
&lt;p>Внимание! Если у вас Yubikey Neo - вы &lt;strong>не можете использовать 4096-битные ключи.&lt;/strong>&lt;/p>
&lt;p>Теперь (наконец-то!) приступим к созданию ключей. Вопрос политики устаревания ключей в целом довольно дискуссионный, и тут я не могу ничего порекомендовать. В данном примере я создам мастер-ключ с бесконечным сроком жизни, а саб-ключи мы потом отредактируем и они будут жить по 5 лет. В процессе создания ключа GPG спросит пароль для шифрования off-card резервной копии. Она вам потребуется, если вы потеряете физический ключ. Off-card экспортируется только subkey для шифрования (capability - E). Остальные sub-ключи и мастер-ключ останутся на карте и вынуть оттуда их нельзя. Процесс генерации ключа зависит от выбранного размера ключа (4096 бит будет генерироваться дольше, чем 2048):&lt;/p>
&lt;pre>&lt;code>gpg/card&amp;gt; generate
Make off-card backup of encryption key? (Y/n) y
Please specify how long the key should be valid.
0 = key does not expire
&amp;lt;n&amp;gt; = key expires in n days
&amp;lt;n&amp;gt;w = key expires in n weeks
&amp;lt;n&amp;gt;m = key expires in n months
&amp;lt;n&amp;gt;y = key expires in n years
Key is valid for? (0) 0
Key does not expire at all
Is this correct? (y/N) y
GnuPG needs to construct a user ID to identify your key.
Real name: Paul Rudnitskiy
Email address: me@prudnitskiy.pro
Comment: YBKey
You selected this USER-ID:
&amp;quot;Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;&amp;quot;
Change (N)ame, (C)omment, (E)mail or (O)kay/(Q)uit? O
[...]
We need to generate a lot of random bytes. It is a good idea to perform
some other action (type on the keyboard, move the mouse, utilize the
disks) during the prime generation; this gives the random number
generator a better chance to gain enough entropy.
gpg: Note: backup of card key saved to '/Users/logan/.gnupg/sk_8E0418955A55C1A8.gpg'
gpg: key 9ECF9961A551A45B marked as ultimately trusted
gpg: revocation certificate stored as '/Users/logan/.gnupg/openpgp-revocs.d/707C3210B50A430B555DD6AC9ECF9961A551A45B.rev'
public and secret key created and signed.
&lt;/code>&lt;/pre>
&lt;p>Ключ готов. Резервную копию забираем из &lt;code>/Users/logan/.gnupg/sk_8E0418955A55C1A8.gpg&lt;/code> (у вас место будет другим) и прячем в надежное место. Пароль резервной копии тоже прячем в надежное место, но &lt;em>другое&lt;/em>. Обязательно удалите резервную копию с той машины, где вы работаете с ключом.&lt;/p>
&lt;p>Проверим, что ключ сгенерировался:&lt;/p>
&lt;pre>&lt;code>gpg/card&amp;gt; list
Reader ...........: Yubico Yubikey 4 OTP U2F CCID
Application ID ...: D2760001240102010006070171690000
Version ..........: 2.1
Manufacturer .....: Yubico
Serial number ....: 07017169
Name of cardholder: Paul Rudnitskiy
Language prefs ...: en
Sex ..............: male
URL of public key : [not set]
Login data .......: logan
Signature PIN ....: not forced
Key attributes ...: rsa4096 rsa4096 rsa4096
Max. PIN lengths .: 127 127 127
PIN retry counter : 3 0 3
Signature counter : 4
Signature key ....: 707C 3210 B50A 430B 555D D6AC 9ECF 9961 A551 A45B
created ....: 2018-08-07 07:58:18
Encryption key....: 062A ABF7 6FB0 8EF4 0E97 4B47 8E04 1895 5A55 C1A8
created ....: 2018-08-07 07:58:18
Authentication key: 6A41 D75C 2B56 41FC A7F4 8DBE CC02 AF33 8EE7 E338
created ....: 2018-08-07 07:58:18
General key info..: pub rsa4096/9ECF9961A551A45B 2018-08-07 Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;
sec&amp;gt; rsa4096/9ECF9961A551A45B created: 2018-08-07 expires: never
card-no: 0006 07017169
ssb&amp;gt; rsa4096/CC02AF338EE7E338 created: 2018-08-07 expires: never
card-no: 0006 07017169
ssb&amp;gt; rsa4096/8E0418955A55C1A8 created: 2018-08-07 expires: never
card-no: 0006 07017169
&lt;/code>&lt;/pre>
&lt;p>Все в порядке, уходим:&lt;/p>
&lt;pre>&lt;code>gpg/card&amp;gt; quit
&lt;/code>&lt;/pre>
&lt;p>Теперь зададим срок жизни сабключей. Он нужен для того, чтобы если по какой-то причине вы потеряли доступ к копии ключа – им нельзя было пользовать после истечения срока жизни ключа. Для этого надо выйти из режима редактирования карты и отредактировать ключ. Редактивровать мы будем SEC-ключ, в этом примере это &lt;em>9ECF9961A551A45B&lt;/em>:&lt;/p>
&lt;pre>&lt;code>tungsten&amp;gt; gpg --edit-key 9ECF9961A551A45B
gpg (GnuPG/MacGPG2) 2.2.8; Copyright (C) 2018 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Secret key is available.
gpg: checking the trustdb
gpg: marginals needed: 3 completes needed: 1 trust model: pgp
gpg: depth: 0 valid: 5 signed: 0 trust: 0-, 0q, 0n, 0m, 0f, 5u
gpg: next trustdb check due at 2024-05-30
sec rsa4096/9ECF9961A551A45B
created: 2018-08-07 expires: never usage: SC
card-no: 0006 07017169
trust: ultimate validity: ultimate
ssb rsa4096/CC02AF338EE7E338
created: 2018-08-07 expires: never usage: A
card-no: 0006 07017169
ssb rsa4096/8E0418955A55C1A8
created: 2018-08-07 expires: never usage: E
card-no: 0006 07017169
[ultimate] (1). Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Команда &lt;code>key NUM&lt;/code> выберет ключ для редактирования. Чтобы снять выбор - нужно ввести ее повторно:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; key 1
sec rsa4096/9ECF9961A551A45B
created: 2018-08-07 expires: never usage: SC
card-no: 0006 07017169
trust: ultimate validity: ultimate
ssb* rsa4096/CC02AF338EE7E338
created: 2018-08-07 expires: never usage: A
card-no: 0006 07017169
ssb rsa4096/8E0418955A55C1A8
created: 2018-08-07 expires: never usage: E
card-no: 0006 07017169
[ultimate] (1). Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Меняем срок жизни:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; expire
Changing expiration time for a subkey.
Please specify how long the key should be valid.
0 = key does not expire
&amp;lt;n&amp;gt; = key expires in n days
&amp;lt;n&amp;gt;w = key expires in n weeks
&amp;lt;n&amp;gt;m = key expires in n months
&amp;lt;n&amp;gt;y = key expires in n years
Key is valid for? (0) 5y
Key expires at Sun Aug 6 11:01:18 2023 MSK
Is this correct? (y/N) y
sec rsa4096/9ECF9961A551A45B
created: 2018-08-07 expires: never usage: SC
card-no: 0006 07017169
trust: ultimate validity: ultimate
ssb* rsa4096/CC02AF338EE7E338
created: 2018-08-07 expires: 2023-08-06 usage: A
card-no: 0006 07017169
ssb rsa4096/8E0418955A55C1A8
created: 2018-08-07 expires: never usage: E
card-no: 0006 07017169
[ultimate] (1). Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Снимаем выделение первого ключа и меняем второй по аналогии:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; key 1
sec rsa4096/9ECF9961A551A45B
created: 2018-08-07 expires: never usage: SC
card-no: 0006 07017169
trust: ultimate validity: ultimate
ssb rsa4096/CC02AF338EE7E338
created: 2018-08-07 expires: 2023-08-06 usage: A
card-no: 0006 07017169
ssb rsa4096/8E0418955A55C1A8
created: 2018-08-07 expires: never usage: E
card-no: 0006 07017169
[ultimate] (1). Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;
gpg&amp;gt; key 2
sec rsa4096/9ECF9961A551A45B
created: 2018-08-07 expires: never usage: SC
card-no: 0006 07017169
trust: ultimate validity: ultimate
ssb rsa4096/CC02AF338EE7E338
created: 2018-08-07 expires: 2023-08-06 usage: A
card-no: 0006 07017169
ssb* rsa4096/8E0418955A55C1A8
created: 2018-08-07 expires: never usage: E
card-no: 0006 07017169
[ultimate] (1). Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;
gpg&amp;gt; expire
Changing expiration time for a subkey.
Please specify how long the key should be valid.
0 = key does not expire
&amp;lt;n&amp;gt; = key expires in n days
&amp;lt;n&amp;gt;w = key expires in n weeks
&amp;lt;n&amp;gt;m = key expires in n months
&amp;lt;n&amp;gt;y = key expires in n years
Key is valid for? (0) 5y
Key expires at Sun Aug 6 11:01:29 2023 MSK
Is this correct? (y/N) y
sec rsa4096/9ECF9961A551A45B
created: 2018-08-07 expires: never usage: SC
card-no: 0006 07017169
trust: ultimate validity: ultimate
ssb rsa4096/CC02AF338EE7E338
created: 2018-08-07 expires: 2023-08-06 usage: A
card-no: 0006 07017169
ssb* rsa4096/8E0418955A55C1A8
created: 2018-08-07 expires: 2023-08-06 usage: E
card-no: 0006 07017169
[ultimate] (1). Paul Rudnitskiy (YBKey) &amp;lt;me@prudnitskiy.pro&amp;gt;
gpg&amp;gt; save
&lt;/code>&lt;/pre>
&lt;p>Ключ на карте готов к использованию&lt;/p>
&lt;h2 id="перенос-существующего-ключа-на-yubikey" >
&lt;div>
&lt;a href="#%d0%bf%d0%b5%d1%80%d0%b5%d0%bd%d0%be%d1%81-%d1%81%d1%83%d1%89%d0%b5%d1%81%d1%82%d0%b2%d1%83%d1%8e%d1%89%d0%b5%d0%b3%d0%be-%d0%ba%d0%bb%d1%8e%d1%87%d0%b0-%d0%bd%d0%b0-yubikey">
#
&lt;/a>
Перенос существующего ключа на Yubikey
&lt;/div>
&lt;/h2>
&lt;p>Этот раздел вам нужен, если у вас уже есть gpg-ключ и вы хотите его перенести на карту. &lt;em>Вы не сможете экспортировать приватный ключ с карты yubikey.&lt;/em>&lt;/p>
&lt;p>После того, как карта сконфигурирована, открываем режим редактирования ключа:&lt;/p>
&lt;pre>&lt;code>tungsten&amp;gt; gpg --expert --edit-key 21F7B93A71CDF86D649D8D0661BEBC7784A83F16
gpg (GnuPG/MacGPG2) 2.2.8; Copyright (C) 2018 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Secret key is available.
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Ключи переносятся командой &lt;code>keytocard&lt;/code>. На Yubikey есть только три слота под три типа (capability) ключа:&lt;/p>
&lt;ul>
&lt;li>Encryption key&lt;/li>
&lt;li>Authentication key&lt;/li>
&lt;li>Sign key&lt;/li>
&lt;/ul>
&lt;p>Если у вас больше ключей - то вы должны решить, какие ключи вы будете переносить. В примере выше - 2 sign ключа, по этому мастер мы переносить не будем - на yubikey уедут только три сабключа. Перед началом переноса ключей рекомендую сделать backup и положить его в безопасное место.&lt;/p>
&lt;p>Выберем ключ для переноса:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; key 1
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb* rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Перенесем его:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; keytocard
Please select where to store the key:
(2) Encryption key
Your selection? 2
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb* rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>После переноса снимем выделение с него:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; key 1
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>По аналогии перенесем 2 и 3 ключи:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; key 2
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb* rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
gpg&amp;gt; keytocard
Please select where to store the key:
(3) Authentication key
Your selection? 3
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb* rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
gpg&amp;gt; key 2
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
gpg&amp;gt; key 3
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb* rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
gpg&amp;gt; keytocard
Please select where to store the key:
(1) Signature key
(3) Authentication key
Your selection? 1
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb* rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[ultimate] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
&lt;/code>&lt;/pre>
&lt;p>Все перенесено, сохраним и проверим:&lt;/p>
&lt;pre>&lt;code>gpg&amp;gt; save
tungsten&amp;gt; gpg --card-edit
Reader ...........: Yubico Yubikey 4 OTP U2F CCID
Application ID ...: D2760001240102010006070171690000
Version ..........: 2.1
Manufacturer .....: Yubico
Serial number ....: 07017169
Name of cardholder: [not set]
Language prefs ...: [not set]
Sex ..............: unspecified
URL of public key : [not set]
Login data .......: [not set]
Signature PIN ....: not forced
Key attributes ...: rsa2048 rsa2048 rsa2048
Max. PIN lengths .: 127 127 127
PIN retry counter : 3 0 3
Signature counter : 0
Signature key ....: 21F7 B93A 71CD F86D 649D 8D06 61BE BC77 84A8 3F16
created ....: 2018-08-08 14:51:38
Encryption key....: 7A30 6771 BB74 204F 54D5 8A61 1200 D2BB 8DFB 614C
created ....: 2018-08-08 14:51:38
Authentication key: DDB0 62D0 1BB4 4D01 3819 E450 0BC3 AD72 9F05 D736
created ....: 2018-08-08 14:54:07
General key info..: pub rsa2048/61BEBC7784A83F16 2018-08-08 Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
sec# rsa2048/61BEBC7784A83F16 created: 2018-08-08 expires: 2022-08-08
ssb&amp;gt; rsa2048/1200D2BB8DFB614C created: 2018-08-08 expires: 2022-08-08
card-no: 0006 07017169
ssb&amp;gt; rsa2048/0BC3AD729F05D736 created: 2018-08-08 expires: 2022-08-07
card-no: 0006 07017169
ssb&amp;gt; rsa2048/FAF7641B57B14FF2 created: 2018-08-08 expires: 2022-08-07
card-no: 0006 07017169
&lt;/code>&lt;/pre>
&lt;p>Обратите внимание, что мастер-ключ не лежит на карте – он пока еще хранится на компьютере (и внутри бэкапа). Имея доступ к мастер-ключу - можно редактировать срок жизни sub-ключа или отозвать (revoke) его. Очень важно хранить мастер в безопасности. Для этого мы вынесем его в холодное хранилище:&lt;/p>
&lt;ul>
&lt;li>у вас должна быть резервная копия мастер-ключа&lt;/li>
&lt;li>экспортируем публичный ключ&lt;/li>
&lt;li>удалим все &lt;em>секретные&lt;/em> ключи с компьютера&lt;/li>
&lt;li>импортируем обратно публичный ключ, сделав его доверенным&lt;/li>
&lt;/ul>
&lt;p>Экспортируем публичный ключ:&lt;/p>
&lt;pre>&lt;code>gpg --export --armour 61BEBC7784A83F16 &amp;gt; pub.asc
&lt;/code>&lt;/pre>
&lt;p>Уберем из компьютера yubikey и удалим приватный ключ:&lt;/p>
&lt;pre>&lt;code>gpg --edit-key 61BEBC7784A83F16
gpg&amp;gt; delkey
&lt;/code>&lt;/pre>
&lt;p>импортируем публичный ключ обратно:&lt;/p>
&lt;pre>&lt;code>gpg --import &amp;lt; pub.asc
&lt;/code>&lt;/pre>
&lt;p>повысим ему уровень доверия&lt;/p>
&lt;pre>&lt;code>gpg --edit-key 61BEBC7784A83F16
gpg&amp;gt; trust
sec rsa2048/61BEBC7784A83F16
created: 2018-08-08 expires: 2022-08-08 usage: SC
trust: ultimate validity: ultimate
ssb rsa2048/1200D2BB8DFB614C
created: 2018-08-08 expires: 2022-08-08 usage: E
ssb rsa2048/0BC3AD729F05D736
created: 2018-08-08 expires: 2022-08-07 usage: A
ssb rsa2048/FAF7641B57B14FF2
created: 2018-08-08 expires: 2022-08-07 usage: S
[none] (1). Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
Please decide how far you trust this user to correctly verify other users' keys
(by looking at passports, checking fingerprints from different sources, etc.)
1 = I don't know or won't say
2 = I do NOT trust
3 = I trust marginally
4 = I trust fully
5 = I trust ultimately
m = back to the main menu
Your decision? 5
Do you really want to set this key to ultimate trust? (y/N) y
&lt;/code>&lt;/pre>
&lt;p>Теперь проверим, что ключи на карте видны:&lt;/p>
&lt;pre>&lt;code>tungsten&amp;gt; gpg --card-edit
Reader ...........: Yubico Yubikey 4 OTP U2F CCID
Application ID ...: D2760001240102010006070171690000
Version ..........: 2.1
Manufacturer .....: Yubico
Serial number ....: 07017169
Name of cardholder: [not set]
Language prefs ...: [not set]
Sex ..............: unspecified
URL of public key : [not set]
Login data .......: [not set]
Signature PIN ....: not forced
Key attributes ...: rsa2048 rsa2048 rsa2048
Max. PIN lengths .: 127 127 127
PIN retry counter : 3 0 3
Signature counter : 0
Signature key ....: 21F7 B93A 71CD F86D 649D 8D06 61BE BC77 84A8 3F16
created ....: 2018-08-08 14:51:38
Encryption key....: 7A30 6771 BB74 204F 54D5 8A61 1200 D2BB 8DFB 614C
created ....: 2018-08-08 14:51:38
Authentication key: DDB0 62D0 1BB4 4D01 3819 E450 0BC3 AD72 9F05 D736
created ....: 2018-08-08 14:54:07
General key info..: pub rsa2048/61BEBC7784A83F16 2018-08-08 Paul Rudnitskiy &amp;lt;me@prudnitskiy.pro&amp;gt;
sec# rsa2048/61BEBC7784A83F16 created: 2018-08-08 expires: 2022-08-08
ssb&amp;gt; rsa2048/1200D2BB8DFB614C created: 2018-08-08 expires: 2022-08-08
card-no: 0006 07017169
ssb&amp;gt; rsa2048/0BC3AD729F05D736 created: 2018-08-08 expires: 2022-08-07
card-no: 0006 07017169
ssb&amp;gt; rsa2048/FAF7641B57B14FF2 created: 2018-08-08 expires: 2022-08-07
card-no: 0006 07017169
&lt;/code>&lt;/pre>
&lt;p>Отлично, ключи видны, можно пользоваться.&lt;/p>
&lt;h2 id="выводы" >
&lt;div>
&lt;a href="#%d0%b2%d1%8b%d0%b2%d0%be%d0%b4%d1%8b">
#
&lt;/a>
Выводы
&lt;/div>
&lt;/h2>
&lt;p>Использование gpg-ключа с карты практически ничем не отличается от использования ключа без карты. Для авторизации по ssh с использованием ключа вам потребуется RSA pubkey. Он создается от gpg subkey A (Auth capability). Если вы меняете auth-ключ – ssh-ключ поменяется тоже, имейте ввиду. Чтобы его получить - достаточно набрать команду &lt;code>ssh-add -L&lt;/code>&lt;/p>
&lt;pre>&lt;code>ssh-add -L
ssh-rsa AAAAB***************************** cardno:00007017169
&lt;/code>&lt;/pre>
&lt;p>Комментарий cardno подскажет, что ключ был импортирован из yubikey&lt;/p>
&lt;p>На каждую попытку использовать ключ yubikey будет требовать ввод User PIN. Yubikey весьма безопасен и надежен, если не делать глупых ошибок в его использовании и применении. И разумеется - нельзя забывать о бэкапах.&lt;/p></description></item></channel></rss>