<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>backup on SRE Blog</title><link>https://prudnitskiy.pro/tags/backup/</link><description>SRE Blog (backup)</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Tue, 23 Jun 2020 23:00:00 +0000</lastBuildDate><atom:link href="https://prudnitskiy.pro/tags/backup/index.xml" rel="self" type="application/rss+xml"/><item><title>Restic: backup для современного мира</title><link>https://prudnitskiy.pro/post/2020-06-23-restic-quickstart/</link><pubDate>Tue, 23 Jun 2020 23:00:00 +0000</pubDate><guid>https://prudnitskiy.pro/post/2020-06-23-restic-quickstart/</guid><description>&lt;p>Restic - это простой, надежный, быстрый и эффективный способ резервного копирования. Простой в установке и настройке, с поддержкой большого количества бэкендов хранения, надежным шифрованием и дедупликацией. Это прекрасный инструмент для резервного копирования в современном ИТ-ландшафте. Тут я расскажу, зачем он нужен, как его поставить и начать им пользоваться.&lt;/p>
&lt;h1 id="теоретическая-часть" >Теоретическая часть
&lt;span>
&lt;a href="#%d1%82%d0%b5%d0%be%d1%80%d0%b5%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b0%d1%8f-%d1%87%d0%b0%d1%81%d1%82%d1%8c">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;h2 id="предыстория" >Предыстория
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%b5%d0%b4%d1%8b%d1%81%d1%82%d0%be%d1%80%d0%b8%d1%8f">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Исторически сложилось, что системы резервного копирования устроены очень сложно. Их сложно устанавливать, настраивать и сопровождать. Руководство к Veritas NetBackup (в дальнейшем - Symantec) имеет размеры приличной книги, по этой системе можно сдать экзамен и получить сертификат. Конфиг Amanda или Bacula весит под сотню килобайт, а официальное руководство занимает больше 500 страниц. Разумеется - у этой поражающей сложности есть простая, понятная, логичная причина, даже две:&lt;/p>
&lt;ul>
&lt;li>ненадежность медиа&lt;/li>
&lt;li>сложность процедуры бэкапа&lt;/li>
&lt;/ul>
&lt;h3 id="ненадежные-медиа" >Ненадежные медиа
&lt;span>
&lt;a href="#%d0%bd%d0%b5%d0%bd%d0%b0%d0%b4%d0%b5%d0%b6%d0%bd%d1%8b%d0%b5-%d0%bc%d0%b5%d0%b4%d0%b8%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Резервные копии надо где-то хранить. Традиционно используются цифровые кассеты (DAT/DLT), CD (в дальнейшем - DVD и BD) ROM/RW и жесткие диски. Проблема физических медиа в их не абсолютной надежности: кассеты размагничиваются и осыпаются, диски - царапаются и страдают от деградаций красочного слоя, про жесткие диски и говорить нечего. Из-за этого &amp;ldquo;классические&amp;rdquo; системы резервного копирования имеют сложные структуры расписаний и управление медиа-пулом. Медианосители надо постоянно перетасовывать, чтобы нагрузка на чтение и запись была равномерной и чтобы не оказалось, что весь огромный многотеррабайтный бэкап зависит от одного-единственного диска, который только что рассыпался в дисководе. Сложное расписание умножается на сложную структуру бэкапов (полный, инкрементальный, дифференциальный) где каждый слой зависит от другого. Это делается для экономия места и времени бэкапа. Кроме этого медиа ограничены в размере, а потому - нужно иметь возможность точно отфильтровать файлы и писать только то, что реально необходимо.&lt;/p>
&lt;h3 id="сложная-процедура-бэкапа" >Сложная процедура бэкапа
&lt;span>
&lt;a href="#%d1%81%d0%bb%d0%be%d0%b6%d0%bd%d0%b0%d1%8f-%d0%bf%d1%80%d0%be%d1%86%d0%b5%d0%b4%d1%83%d1%80%d0%b0-%d0%b1%d1%8d%d0%ba%d0%b0%d0%bf%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>В классическом традиционном ИТ-подходе бэкап - это очень сложная процедура. Бэкапим мы файлы, но данные нельзя воспринимать как файлы - они меняются. Бэкап файлов &amp;ldquo;в лоб&amp;rdquo; провоцирует инконсистентные данные, когда что-то поменялось на ходу и часть файлов находится в состоянии &amp;ldquo;до&amp;rdquo;, а часть - уже &amp;ldquo;после&amp;rdquo;. В том же Veritas NetBackup львиную долю цены лицензий состовляла цена агентов - сущностей, которые помогали бэкапить конкретные базы (Oracle, MSSQL) или состояния конкретных продуктов (SAP, BAAN). Агент знал, как &amp;ldquo;заморозить&amp;rdquo; состояние системы и получить консистентный бэкап, без него резервное копирование превращалось в лотерею. В opensource решениях агентов обычно нет, но родовые травмы в виде PreTask/PostTask остались - нужно подготовить данные к резервному копированию, а потом - вывести систему из этого состояния.&lt;/p>
&lt;h2 id="restic-новый-подход" >Restic: новый подход
&lt;span>
&lt;a href="#restic-%d0%bd%d0%be%d0%b2%d1%8b%d0%b9-%d0%bf%d0%be%d0%b4%d1%85%d0%be%d0%b4">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Restic задуман как резервное копирование для современного ИТ-мира. Он имеет простой (предельно простой) интерфейс и минимум настроек. Одно из главных нововведений Restic - отказ от сложных медиа-операций. В современном ИТ в качестве системы хранения используется внешний сервис хранения, доступный обычно по S3 (Amazon S3, Azure BlobStorage, DigitalOcean Spaces, Minio на собственном оборудовании) или через прослойку в виде rclone (dropbox, Yandex.Disk). Restic предполагает такой бэкенд &lt;em>небезопасным, но надежным&lt;/em>. Разумеется, данные внутри Amazon S3 хранятся на медиа, и медиа эти ненадежны. Однако между пользователем и медиа - несколько слоев абстракции, которые защищают данные, следят за их целостностью и верификацией. RAID-контроллеры, Erasure Codes, репликация между серверами-стойками-датацентрами, media scrubbing, check-суммы блоков - технологий десятки, если не сотни. По словам Dropbox - 80% трафика внутри их датацентров составляет служебный трафик, верификация, репликация и проверки данных, и только 20% - это собственно пользовательские данные. Restic исходит из идеи, что данные во внешнем хранилище содержатся вполне надежно и шансы получить битый или потеряный блок - минимальны. Именно по этому в Restic &lt;strong>нет разделения на типы бэкапов - полные, инкрементальные и дифференциальные&lt;/strong>. Вместо этого предложен механизм snapshot-тов. Это просто снимок состояния системы в момент времени.&lt;/p>
&lt;h3 id="как-хранятся-данные" >Как хранятся данные
&lt;span>
&lt;a href="#%d0%ba%d0%b0%d0%ba-%d1%85%d1%80%d0%b0%d0%bd%d1%8f%d1%82%d1%81%d1%8f-%d0%b4%d0%b0%d0%bd%d0%bd%d1%8b%d0%b5">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Так как restic предполагает, что медиа - небезопасно - все данные шифруются AES256-CTR. Ключ AES шифруется паролем. Содержимое файлов нарезается на блоки (blobs) переменной длины (от 512кб до 8Мб), при этом каждый blob имеет контрольную сумму (CDC). Блоки упаковываются в пачки (pack). Пачка хранит в себе содержимое файла с метаданными или дерево (то есть - хранит в себе ссылки на другие пачки - файлы). Разные пачки могут ссылаться на один и тот же blob, что позволяет значительно экономить место. На самом верху этой пирамиды восседает snapshot, который хранит метаданные о, собственно, бэкапе (кто, когда, где) и ссылку на пачку с деревом верхнего уровня. При этом разные snapshot-ы могут ссылаться на одни и те же пачки деревьев, а пачки деревьев - на одни и те же пачки файлов (если файлы не менялись). Restic имеет удобную команду &lt;code>restic cat blob &amp;lt;blobId&amp;gt;&lt;/code>, которая позволяет посмотреть в содержимое конкретного блоба и выяснить, что там лежит.&lt;/p>
&lt;h1 id="практическая-часть" >Практическая часть
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%b0%d0%ba%d1%82%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%b0%d1%8f-%d1%87%d0%b0%d1%81%d1%82%d1%8c">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h1>&lt;h2 id="установка-и-инициализация-repository" >Установка и инициализация repository
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%b8-%d0%b8%d0%bd%d0%b8%d1%86%d0%b8%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d1%8f-repository">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Restic написан на go и потому распространяется в виде единственно бинарного файла, который содержит все необходимое. В Debian и Ubuntu он есть в виде пакета, так что поставить можно традиционно:&lt;/p>
&lt;pre>&lt;code>apt-get install -y restic
&lt;/code>&lt;/pre>
&lt;p>Ну или просто скачать готовый binary &lt;a href="https://github.com/home/projects/restic/releases/">отсюда&lt;/a>.&lt;/p>
&lt;p>После установки нужно инициализировать repo. При этом restic сгенерирует ключ для шифрования и создаст структуру каталогов для хранения blob-ов, паков и snapshot-ов. Тут нужно сделать небольшое отступление: в рамках одного repo можно хранить бэкапы разных каталогов и даже разных хостов. Структура repo restic-а позволяет это делать и бэкапы не будут пересекаться друг с другом (hostname и path бэкапа - обязательный атрибут snapshot-а, так что можно легко отфильтровать нужный). Блобы общие в рамках repo, по этому если три разных хоста хранят одинаковый файл - в repo он будет хранится в одном блобе, что позволит сэкономить место.&lt;/p>
&lt;p>Инициализация выполняется командой &lt;code>init&lt;/code>&lt;/p>
&lt;pre>&lt;code># для локальной файловой системы:
restic init --repo /mnt/disk0/backup-repo
# для S3-совместимых серверов (Minio, CEPH ObjGateway)
export AWS_ACCESS_KEY_ID=&amp;lt;MY_ACCESS_KEY&amp;gt;
export AWS_SECRET_ACCESS_KEY=&amp;lt;MY_SECRET_ACCESS_KEY&amp;gt;
restic init --repo s3:https://my.local.server/backup-repo
# для Amazon S3 (European bucket)
export AWS_ACCESS_KEY_ID=&amp;lt;MY_ACCESS_KEY&amp;gt;
export AWS_SECRET_ACCESS_KEY=&amp;lt;MY_SECRET_ACCESS_KEY&amp;gt;
restic init -o s3.region=&amp;quot;eu-west-1&amp;quot; --repo s3://s3.eu-west-1.amazonaws.com/bucketName/backupRepo
&lt;/code>&lt;/pre>
&lt;p>Главное - не забыть пароль, про который спросит restic. Именно этим паролем шифруется ключ и если пароль посеять - шансов на распаковку будет примерно ноль.&lt;/p>
&lt;h2 id="типовые-операции" >Типовые операции
&lt;span>
&lt;a href="#%d1%82%d0%b8%d0%bf%d0%be%d0%b2%d1%8b%d0%b5-%d0%be%d0%bf%d0%b5%d1%80%d0%b0%d1%86%d0%b8%d0%b8">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;h3 id="бэкап" >Бэкап
&lt;span>
&lt;a href="#%d0%b1%d1%8d%d0%ba%d0%b0%d0%bf">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Бэкап - основная операция, которая выполняется (по-хорошему), чаще всего:&lt;/p>
&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo backup /home/projects
&lt;/code>&lt;/pre>
&lt;p>Не всегда нужны все файлы. Для таких случаев есть ключ &lt;code>--exclude-file&lt;/code>. В этот можно добавить как конкретные файлы и папки (путь должен быть относительным, от корня бэкапа), так и regexp. Для парсинга файла используется filepath.Glob, так что синтаксис в деталях можно посмотреть &lt;a href="https://golang.org/pkg/path/filepath/#Match">тут&lt;/a>.&lt;/p>
&lt;p>Пример файла:&lt;/p>
&lt;pre>&lt;code># просто папки
tmp
out
# файлы по расширению
*.deb
*.rpm
*.pyc
*.pyo
# файлы по пути. К примеру /home/projects/a/b/c/temp /home/projects/a/temp /home/projects/temp
/home/projects/**/temp
&lt;/code>&lt;/pre>
&lt;h3 id="получение-списка-snapshot-ов-из-которых-можно-восстанавливать" >Получение списка snapshot-ов (из которых можно восстанавливать):
&lt;span>
&lt;a href="#%d0%bf%d0%be%d0%bb%d1%83%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d1%81%d0%bf%d0%b8%d1%81%d0%ba%d0%b0-snapshot-%d0%be%d0%b2-%d0%b8%d0%b7-%d0%ba%d0%be%d1%82%d0%be%d1%80%d1%8b%d1%85-%d0%bc%d0%be%d0%b6%d0%bd%d0%be-%d0%b2%d0%be%d1%81%d1%81%d1%82%d0%b0%d0%bd%d0%b0%d0%b2%d0%bb%d0%b8%d0%b2%d0%b0%d1%82%d1%8c">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo snaphots
repository 365c035e opened successfully, password is correct
ID Time Host Tags Paths
----------------------------------------------------------------------
119a1eb2 2020-04-30 15:48:20 mynote mynote,work /home/projects
ee597f8e 2020-05-31 00:30:01 mynote mynote,work /home/projects
a43ffe6a 2020-06-07 22:12:33 mynote mynote,work /home/projects
1d70de01 2020-06-10 00:32:43 mynote mynote,work /home/projects
0c236089 2020-06-12 18:44:56 mynote mynote,work /home/projects
e557bc74 2020-06-15 23:53:01 mynote mynote,work /home/projects
b39cf3de 2020-06-17 23:07:33 mynote mynote,work /home/projects
677b00d2 2020-06-19 11:40:50 mynote mynote,work /home/projects
8b781249 2020-06-20 00:07:52 mynote mynote,work /home/projects
d7c588a3 2020-06-23 10:15:06 mynote mynote,work /home/projects
----------------------------------------------------------------------
&lt;/code>&lt;/pre>
&lt;h3 id="сравнение-двух-snapshot-ов-дельта" >Сравнение двух snapshot-ов (дельта):
&lt;span>
&lt;a href="#%d1%81%d1%80%d0%b0%d0%b2%d0%bd%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b4%d0%b2%d1%83%d1%85-snapshot-%d0%be%d0%b2-%d0%b4%d0%b5%d0%bb%d1%8c%d1%82%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo diff 119a1eb2 ee597f8e
password is correct
comparing snapshot 119a1eb2 to ee597f8e:
C /home/projects/cmd_diff.go
+ /home/projects/foo
C /home/projects/restic
Files: 0 new, 0 removed, 2 changed
Dirs: 1 new, 0 removed
Others: 0 new, 0 removed
Data Blobs: 14 new, 15 removed
Tree Blobs: 2 new, 1 removed
Added: 16.403 MiB
Removed: 16.402 MiB
&lt;/code>&lt;/pre>
&lt;h3 id="просмотр-списка-файлов-в-snapshot-е" >Просмотр списка файлов в snapshot-е
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%be%d1%81%d0%bc%d0%be%d1%82%d1%80-%d1%81%d0%bf%d0%b8%d1%81%d0%ba%d0%b0-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2-%d0%b2-snapshot-%d0%b5">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Так можно посмотреть все файлы, которые можно найти в snapshot-е&lt;/p>
&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo ls -l latest
snapshot d7c588a3 of [/home/projects] filtered by [] at 2020-06-23 10:15:06.972887989 +0300 MSK):
/home
/home/projects
/home/projects/.ICEauthority
/home/projects/.PyCharmCE2019.3
/home/projects/.PyCharmCE2019.3/config
/home/projects/.PyCharmCE2019.3/config/codestyles
/home/projects/.PyCharmCE2019.3/config/codestyles/Default.xml
/home/projects/.PyCharmCE2019.3/config/inspection
/home/projects/.PyCharmCE2019.3/config/inspection/Default.xml
/home/projects/.PyCharmCE2019.3/config/options
/home/projects/.PyCharmCE2019.3/config/options/colors.scheme.xml
/home/projects/.PyCharmCE2019.3/config/options/debugger.xml
[...]
&lt;/code>&lt;/pre>
&lt;p>А так можно найти определенный (если восстановить хочется не все, а только определенные файлы):&lt;/p>
&lt;pre>&lt;code>restic find &amp;quot;**/blog/**/*.md&amp;quot; --snapshot latest
repository 365c035e opened successfully, password is correct
Found matching entries in snapshot d7c588a3
/home/projects/blog/_drafts/2017-11-06-deadend.md
/home/projects/blog/_drafts/2018-02-06-newway.md
/home/projects/blog/_posts/2005-01-14-openssh-key-auth.md
[...]
&lt;/code>&lt;/pre>
&lt;h3 id="восстановление-из-бэкапа" >Восстановление из бэкапа
&lt;span>
&lt;a href="#%d0%b2%d0%be%d1%81%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b8%d0%b7-%d0%b1%d1%8d%d0%ba%d0%b0%d0%bf%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Самый простой вариант - восстановить все файлы из определенного snapshot-а. Latest как ID snapshot-а автоматически преобразуется в последний доступный snapshot&lt;/p>
&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo restore latest --target=tmptest/
repository 365c035e opened successfully, password is correct
restoring &amp;lt;Snapshot d7c588a3 of [/home/projects] at 2020-06-23 10:15:06.972887989 +0300 MSK by logan@mynote&amp;gt; to tmptest/
&lt;/code>&lt;/pre>
&lt;p>Если восстанавливать хочется не все - есть ключ &lt;code>--include&lt;/code>:&lt;/p>
&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo restore latest --target=tmptest/ --include &amp;quot;.PyCharmCE2019.3&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>В этом случае будет восстановлена только папка &lt;code>.PyCharmCE2019.3&lt;/code> со всем ее содержимым. Обратный фокус с ключом &lt;code>--exclude&lt;/code> сработает тоже.&lt;/p>
&lt;h3 id="проверки-snapshot-ов" >Проверки snapshot-ов
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b8-snapshot-%d0%be%d0%b2">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Целосность данных критически важна. Если будет потерян blob - все snapshot-ы, которые ссылаются на него - станут невалидными и не смогут восстановится. Для этой цели есть команда &lt;code>check&lt;/code>:&lt;/p>
&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo check
using temporary cache in /tmp/restic-check-cache-830311414
repository 365c035e opened successfully, password is correct
created new cache in /tmp/restic-check-cache-830311414
create exclusive lock for repository
load indexes
check all packs
check snapshots, trees and blobs
no errors were found
&lt;/code>&lt;/pre>
&lt;h2 id="уборка-в-репозитории" >Уборка в репозитории
&lt;span>
&lt;a href="#%d1%83%d0%b1%d0%be%d1%80%d0%ba%d0%b0-%d0%b2-%d1%80%d0%b5%d0%bf%d0%be%d0%b7%d0%b8%d1%82%d0%be%d1%80%d0%b8%d0%b8">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Restic по умолчанию не имеет политик очистки (retention policy), а значит - репозиторий будет расти вечно, с каждым изменением файла. Чтобы этого избежать - репозиторий надо чистить. Это делается в два шага:&lt;/p>
&lt;ul>
&lt;li>команда &lt;code>forget&lt;/code> удаляет ненужные snapshot-ы из репозитория. Однако она не трогает сами блобы, на которые ссылаются эти snapshot-ы&lt;/li>
&lt;li>команда &lt;code>prune&lt;/code> удаляет блобы, на которые никто не ссылается. Именно в этот момент происходит реальная чистка репозитория.&lt;/li>
&lt;/ul>
&lt;p>Пример использования:&lt;/p>
&lt;pre>&lt;code>restic -r /mnt/disk0/backup-repo forget --keep-daily 7 --keep-weekly 5 --keep-monthly 12
restic -r /mnt/disk0/backup-repo prune
&lt;/code>&lt;/pre>
&lt;p>В этом примере мы храним 7 последних ежедневных snapshot-ов, 4 snapshot-а недельных (что покрывает месяц) и 12 месячных. Это позволит нам вытащить бэкап за весь последний год, причем за последнюю неделю он ежедневный, за месяц - еженедельный а дальше - помесячный. Почему keep-weekly в этом примере равен 5? Потому что последний из 7 keep-daily попадает на недельный (это первый по-недельный snapshot). Чтобы проверить, какие snapshot-ы будут удалены - можно вызвать &lt;code>forget&lt;/code> с ключом &lt;code>--dry-run&lt;/code>. Никакого удаления при этом не производится и можно по выводу команды понять, отрабатывает ли политика так, как задумано.&lt;/p>
&lt;p>Авторы restic рекомендуют запускать check после prune, чтобы убедится, что не произошло повреждения данных.&lt;/p>
&lt;h2 id="использование-в-скриптах" >Использование в скриптах
&lt;span>
&lt;a href="#%d0%b8%d1%81%d0%bf%d0%be%d0%bb%d1%8c%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b2-%d1%81%d0%ba%d1%80%d0%b8%d0%bf%d1%82%d0%b0%d1%85">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Restic прекрасно работает в скриптах, в нем нет интерактивных элементов. Пароль можно задать с помощью переменных окружающей среды:&lt;/p>
&lt;ul>
&lt;li>RESTIC_PASSWORD - пароль repo &amp;ldquo;как есть&amp;rdquo;, открытым текстом без шифрования&lt;/li>
&lt;li>RESTIC_PASSWORD_FILE - файл с паролем repo. Без шифрования. Учитывается только первая строка. Имеет более высокий приоритет, чем RESTIC_PASSWORD (если задан RESTIC_PASSWORD_FILE, RESTIC_PASSWORD не учитывается)&lt;/li>
&lt;li>RESTIC_PASSWORD_COMMAND - команда, выполнение которой вернет пароль. Задавать ее в виде субпроцесса &lt;code>$(command)&lt;/code> не нужно. Хороший вариант, если вы используете для шифрования PGP или менеджер паролей (pass, gopass, 1password-cli). Наивысший приоритет&lt;/li>
&lt;/ul>
&lt;h2 id="заключение" >Заключение
&lt;span>
&lt;a href="#%d0%b7%d0%b0%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Restic - простой, быстрый и при правильном применении - вполне надежный инструмент. Простота настройки снижает риск ошибок, а скорость работы - повышает шансы, что все будет забэкаплено вовремя и как надо. Я очень рекомендую этот инструмент, он показал себя простым, гибким, удобным и надежным. И помните - системные администраторы делятся на две группы: те, кто не делают бэкапы и те, кто &lt;strong>уже делают бэкапы&lt;/strong> :)&lt;/p></description></item><item><title>Duplicity – экстремально простой способ резервного копирования</title><link>https://prudnitskiy.pro/post/2017-09-30-duplicity/</link><pubDate>Sat, 30 Sep 2017 20:50:10 +0000</pubDate><guid>https://prudnitskiy.pro/post/2017-09-30-duplicity/</guid><description>&lt;p>Как гласит старинная шутка, системные администраторы делятся на две группы: те, которые не делают бэкапы, и те, которые уже делают бэкапы. Систем резеревного копирования существует великое множество, от простейшего самописного скрипта до огромных монстров ценой в &amp;ldquo;боинг&amp;rdquo;. Все системы нужны для разных целей и выполняют разные задачи.&lt;/p>
&lt;p>Основная, самая известная и популярная система в мире unix и linux – это, безусловно, bacula. Умеет bacula очень много - сложные расписания и политики хранения, шифрование данных и клиент-серверного трафика, управление операциями &amp;ldquo;на ходу&amp;rdquo;, десятки способов упаковки и проверки данных. Полный список возможностей bacula занимает несколько страниц мелкого текста. Основной минус бакулы находится ровно там, где находится ее плюс. Внедрение и настройка бакулы - это приключение, как минимум, на неделю. Документации очень много (но ее все равно не хватает). Бакула состоит из 4 самостоятельных компонентов (director, storage, filedaemon, console), каждый из которых настраивается и живет отдельно. Все эти компоненты имеют сложные взаимоотношения и должны быть доступны друг другу напрямую, что тоже жизнь не облегчает. Элементарный конфиг bacula легко может весить десятки килобайт (и bacula очень трепетно относится к опечаткам в конфиге - он в лучшем случае вообще не прочитается, а в худшем сервис упадет). В случае, если нужно делать резервные копии с одного-двух серверов - bacula - явный оверкилл. Вместо сложного комбайна нужен простой и понятный молоток. И такой молоток есть - он называется duplicity.&lt;/p>
&lt;p>Duplicity - это очень просто. Это одна-единственная команда, которая запускается на том сервере, откуда будут копироваться данные. Все, что она может:&lt;/p>
&lt;ul>
&lt;li>сделать резервную копию. Резервная копия пакуется в блоки (назывются тома), и, по желанию, шифруются. Резервная копия может быть или полной, или инкрементальной. Уровень определяется возрастом копии - если последняя полная копия старше определенного возраста - будет сделана полная, если нет - инкрементальная копия.&lt;/li>
&lt;li>отправить резервную копию на удаленный сервер. Удаленный сервер может быть rsync, ftp, scp, s3 (вариантов много). Можно хранить прямо в файловой системе. Устройства хранения (ленточные библиотеки, дисковые массивы) – не поддерживатюся.&lt;/li>
&lt;li>найти расходждения между каталогом и определенной версией бекапа. Полезно, чтобы понять, что изменилось с момента бэкапа.&lt;/li>
&lt;li>показать список файлов в бэкапе.&lt;/li>
&lt;li>восстановить файлы из бэкапа (или весь бэкап целиком).&lt;/li>
&lt;li>почистить удаленный сервер от старых бэкапов.&lt;/li>
&lt;/ul>
&lt;p>На этом функционал duplicity заканчивается. Ничего сложного, головоломного, неочевидного. Система, понятная, как кирпич.&lt;/p>
&lt;h2 id="установка-и-настройка" >Установка и настройка
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%b8-%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Duplicty входит в пакет с одноименным названием, и устанавливается традиционно для вашей операционной системы:&lt;/p>
&lt;pre>&lt;code>#debian, ubuntu
apt-get install duplicity
#centos, redhat, fedora
yum install duplicity
&lt;/code>&lt;/pre>
&lt;p>Теперь нужно решить, куда будут отправляться пакеты. Duplicty не может работать с удаленным сервером самостоятельно - в зависимости от типа удаленного сервера ему потребуется тот или иной пакет. Сам duplicity только &amp;ldquo;дирижирует процессом&amp;rdquo;. Самые ходовые типы серверов и пакеты:&lt;/p>
&lt;ul>
&lt;li>ftp, ftps (ftp over TLS): ncftp&lt;/li>
&lt;li>rsync: rsync&lt;/li>
&lt;li>s3 (aws S3, openstack swift, ceph object gateway, minio): boto&lt;/li>
&lt;/ul>
&lt;p>Если планируется шифровать и/или подписывать бэкап - нужно сгенерировать gpg-ключ. Шифровать бэкап рекомендуется, если нет доверия серверу хранения. Правило хорошего тона гласят, что доверия нет никогда и никому. Помните о том, что бэкап, по сути – отложеное по времени нарушение безопасности. Ключ генерируется вполне традиционым способом:&lt;/p>
&lt;pre>&lt;code>gpg --gen-key
&lt;/code>&lt;/pre>
&lt;p>Параметры ключа (размер, алгоритм) менять не обязательно, они вполне разумны. После окончания генерации GPG вернет идентификатор ключа. Его так же можно посмотреть вот так:&lt;/p>
&lt;pre>&lt;code>gpg --list-keys
/root/.gnupg/pubring.gpg
------------------------
pub 2048R/F6822D5F 2017-01-28
uid Paul I Rudnitskiy (bck server) &amp;lt;admin@prudnitskiy.pro&amp;gt;
sub 2048R/292EB891 2017-01-28
&lt;/code>&lt;/pre>
&lt;p>ID нам чуть дальше пригодится, рекомендую его запомнить.&lt;/p>
&lt;p>Так же очень рекомендуется сделать разеревную копию GPG-ключа. Если бэкап зашифрован - потеря ключа автоматически означает потерю возможности восстановить данные из бэкапа. Выгрузим ключ, чтобы сохранить его в надежное место:&lt;/p>
&lt;pre>&lt;code>gpg --export-secret-keys -a F6822D5F &amp;gt; backup.asc
&lt;/code>&lt;/pre>
&lt;h2 id="резервное-копирование" >Резервное копирование
&lt;span>
&lt;a href="#%d1%80%d0%b5%d0%b7%d0%b5%d1%80%d0%b2%d0%bd%d0%be%d0%b5-%d0%ba%d0%be%d0%bf%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Общий принцип - &lt;code>duplicity [args] {source} {destination}&lt;/code>. Аргументов множество, ниже я приведу пример и распишу, что означает каждый. Проще всего сделать shell-скрипт с командой и типовыми аргументами, чтобы не вспоминать их каждый раз&lt;/p>
&lt;pre>&lt;code>duplicity --verbosity notice \
--encrypt-key &amp;quot;F6822D5F&amp;quot; \
--full-if-older-than 14D \
--num-retries 3 \
--asynchronous-upload \
--volsize 100 \
--archive-dir /var/tmp/.duplicity \
--log-file /var/log/duplicity.log \
--exclude &amp;quot;/var/lib/postgresql/9.5/main/archive&amp;quot; \
&amp;quot;/var/lib/postgresql/9.5/main/&amp;quot; \
&amp;quot;ftp://bckuser:iem4ob9bah1FohNi@verysecret.prudnitskiy.pro/pgsql&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>На что обратить внимание:&lt;/p>
&lt;ul>
&lt;li>&lt;em>verbosity&lt;/em> - уровень &amp;ldquo;говорливости&amp;rdquo; при работе. Рекомендуется info при отладке (показывает файлы и текущие операции) и notice в production (кратко сообщает о текущем этапе работы)&lt;/li>
&lt;li>&lt;em>encrypt-key&lt;/em> - ID ключа для шифрования. Важен, если ключей несколько. Если шифровать не нужно - используйте аргумент &lt;code>--no-encryption&lt;/code>. При шифровании gpg спросит пароль ключа шифрования. Побеждается или настройкой gpg-agent или созданием переменной &lt;code>PASSPHRASE&lt;/code> с паролем.&lt;/li>
&lt;li>&lt;em>full-if-older-than&lt;/em> - через срок после создания полной копии нужно сделать не инкрементальную, а снова полную копию. В данном примере - 14 дней.&lt;/li>
&lt;li>&lt;em>volsize&lt;/em> - размер одного тома в мегабайтах. Каждый том пакуется и загружается на сервер отдельно, это отдельный файл.&lt;/li>
&lt;li>&lt;em>archive-dir&lt;/em> - папка, где duplicity локально хранит метаданные (информацию о томах и их содержимом). Копия метаданных лежит на сервере. Если по какой-то причине метаданные пропадут - duplicity придется скачать копию метаданных с сервера перед началом бэкапа. Размер папки метаданных пропорционально зависит от количества файлов и количества бэкапов, так что стоит выделить ей побольше места.&lt;/li>
&lt;li>&lt;em>exclude&lt;/em> - позволяет исключить папку из бэкапа. аргументов exclude может быть несколько.&lt;/li>
&lt;li>&lt;em>destination&lt;/em> - последний аргумент, куда копируем данные. Задается в виде классического url. URL для копии в локальную файловую систему имеет вид &lt;code>file:///path/to/folder&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>Проверка состояния бэкапов на удаленном сервере:&lt;/p>
&lt;pre>&lt;code>duplicity collection-status &amp;quot;ftp://bckuser:iem4ob9bah1FohNi@verysecret.prudnitskiy.pro/pgsql&amp;quot; \
--archive-dir /var/tmp/.duplicity
&lt;/code>&lt;/pre>
&lt;p>Пример ответа:&lt;/p>
&lt;pre>&lt;code>NcFTP version is 3.2.5
Local and Remote metadata are synchronized, no sync needed.
Last full backup date: Fri Sep 15 04:10:03 2017
Collection Status
-----------------
Connecting with backend: FTPBackend
Archive dir: /var/tmp/.duplicity/c9edc22d8a99b972fdf4bd3cec26e19f
Found 1 secondary backup chain.
Secondary chain 1 of 1:
-------------------------
Chain start time: Thu Aug 31 04:10:03 2017
Chain end time: Thu Sep 14 04:10:02 2017
Number of contained backup sets: 15
Total number of contained volumes: 252
Type of backup set: Time: Num volumes:
Full Thu Aug 31 04:10:03 2017 137
Incremental Fri Sep 1 04:10:02 2017 6
----------------------------CUT----------------------------------------
-------------------------
Found primary backup chain with matching signature chain:
-------------------------
Chain start time: Fri Sep 15 04:10:03 2017
Chain end time: Fri Sep 29 04:10:03 2017
Number of contained backup sets: 15
Total number of contained volumes: 245
Type of backup set: Time: Num volumes:
Full Fri Sep 15 04:10:03 2017 142
Incremental Sat Sep 16 04:10:02 2017 8
----------------------------CUT----------------------------------------
Incremental Fri Sep 29 04:10:03 2017 7
-------------------------
No orphaned or incomplete backup sets found.
&lt;/code>&lt;/pre>
&lt;p>Duplicity не позволяет помечать бэкап как устаревший автоматически (retention в терминологии &amp;ldquo;взрослых&amp;rdquo; систем). Чистить ненужные бэкапы придется в ручном режиме:&lt;/p>
&lt;pre>&lt;code>duplicity --verbosity notice \
--archive-dir /var/tmp/.duplicity \
--force \
remove-all-but-n-full 4 \
&amp;quot;ftp://bckuser:iem4ob9bah1FohNi@verysecret.prudnitskiy.pro/pgsql&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Эта команда удалит все бэкапы старше 4 последних полных бэкапов. В примере выше мы делали полный бекап каждые 2 недели, то есть duplicity удалит бэкапы старше 2 месяцев (8 недель). Если убрать ключ &lt;code>--force&lt;/code> – duplicity найдет старые бэкапы, но не будет их удалять - только выведет на консоль. Забывать о чистке не рекомендуется - место на сервере для резервных копий может неожиданно кончиться и оставить вас без свежих бэкапов. Выясняется это весьма болезненно.&lt;/p>
&lt;h2 id="проверка-и-восстановление" >Проверка и восстановление
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%be%d0%b2%d0%b5%d1%80%d0%ba%d0%b0-%d0%b8-%d0%b2%d0%be%d1%81%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Посмотрим файлы, которые у нас есть в бэкапе:&lt;/p>
&lt;pre>&lt;code>duplicity --archive-dir /var/tmp/.duplicity list-current-files \
&amp;quot;ftp://bckuser:iem4ob9bah1FohNi@verysecret.prudnitskiy.pro/pgsql&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Пример ответа:&lt;/p>
&lt;pre>&lt;code>NcFTP version is 3.2.5
Local and Remote metadata are synchronized, no sync needed.
Last full backup date: Sat Sep 29 04:10:03 2017
Mon Oct 2 04:10:02 2017 .
Mon Aug 29 21:07:04 2016 PG_VERSION
Mon Oct 2 04:10:02 2017 backup_label
-----------------------CUT---------------------------------
&lt;/code>&lt;/pre>
&lt;p>Команда выше покажет состояние на момент &lt;em>последнего&lt;/em> бэкапа. Чтобы получить информацию из более старых бэкапов, нужно использовать ключ &lt;code>-t&lt;/code>. К примеру, &lt;code>-t6D&lt;/code> вернет информацию о бэкапе, сделаном 6 дней назад.&lt;/p>
&lt;p>Восстановление данных выглядит ровно так же, как бэкап, нужно просто поменять местами source (откуда брать данные) и destination:&lt;/p>
&lt;pre>&lt;code>duplicity --verbosity notice \
--encrypt-key &amp;quot;F6822D5F&amp;quot; \
--archive-dir /var/tmp/.duplicity \
--log-file /var/log/duplicity.log \
&amp;quot;ftp://bckuser:iem4ob9bah1FohNi@verysecret.prudnitskiy.pro/pgsql&amp;quot; \
&amp;quot;/var/lib/postgresql/9.5/main/&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>На что обратить внимание:&lt;/p>
&lt;ul>
&lt;li>Если нужно восстановить бэкап на определенную дату - выручает ключ &lt;code>-t&lt;/code>&lt;/li>
&lt;li>Для восстановления определенного файла нужно использовать ключ &lt;code>--file-to-restore&lt;/code>. Таких ключей может быть несколько.&lt;/li>
&lt;li>Восстановление возможно только в совершенно пустую папку&lt;/li>
&lt;li>Для восстановления duplicity вытащит с сервера резервных копий &lt;em>весь&lt;/em> полный бэкап и все инкрементальные бэкапы с момента полного до точки восстановления. Места уйдет много.&lt;/li>
&lt;/ul></description></item><item><title>Резервное копироварие mysql с помощью xtrabackup</title><link>https://prudnitskiy.pro/post/2016-04-21-xtrabackup/</link><pubDate>Thu, 21 Apr 2016 00:20:10 +0000</pubDate><guid>https://prudnitskiy.pro/post/2016-04-21-xtrabackup/</guid><description>&lt;p>MySQL - сверх-популярный сервер баз данных. Его используют (или использовали) практически все. Одна из самых популярных задач в системном администрировании - бэкап (и восстановление). Или, как подвид - миграция данных (бэкап + последующее восстановление). Это делают практически все. И практически все используют для mysql_dump, что категорически неправильно и часто просто опасно. В этой статье я расскажу, почему mysql_dump - это плохое решение и что с ним можно сделать.&lt;/p>
&lt;h2 id="проблема" >Проблема
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%be%d0%b1%d0%bb%d0%b5%d0%bc%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>У mysql_dump есть три основных проблемы - скорость, неконсистентность и блокировки. Все три проблемы проистекают из его архитектуры, так что вылечить их невозможно. Чтобы понять проблемы, опишу алгоритм работы mysql_dump:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>mysql_dump получает список таблиц в базе&lt;/p>
&lt;/li>
&lt;li>
&lt;p>он проходит по списку по алфавиту (уже опасный момент)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>для каждой таблицы он делает три действия:&lt;/p>
&lt;/li>
&lt;li>
&lt;p>сначала он снимает структуру. Это очень быстрое действие.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>затем таблица блокируется на запись (целиком)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>после этого mysql_dump выгружает все данные (грубо говоря - делает &lt;code>SELECT * FROM table&lt;/code>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>все выгруженное отправляется на stdout. Обычно stdout перенаправляется в файл (классическая конструкция: &lt;code>mysql_dump dbname &amp;gt; file.sql&lt;/code>)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>после того, как сканирование таблицы заканчивается - блокировка снимается и dump переходит к следующей таблице.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Самая серьезная проблема, которая лежит на поверхности - блокировки. В момент, когда mysql_dump блокирует таблицу - записать в нее что-либо становится невозможно. В лучшем случае изменения в таблице будут накапливаться (если приложение умеет копить изменения и работать с базой асинхронно, как gorm). В худшем случае приложение упадет с ошибкой записи, а пользователь получит фигу в виде ошибки 500. Проблема консистентности лежит глубже, а потому она много опаснее, так как сходу эти грабли неочевидны, а по лбу бьют больно. Рассмотрим пример. У нас есть база, в которой лежит 3 таблицы: &amp;ldquo;affilates&amp;rdquo;, &amp;ldquo;logs&amp;rdquo; и &amp;ldquo;organisations&amp;rdquo;. Таблица logs очень большая. Таблицы affilates и organisations связаны через внешний ключ. Приложение вставляет запись в &amp;ldquo;affilates&amp;rdquo;, а затем - пачку записей в &amp;ldquo;organisations&amp;rdquo; с ключом, указывающим на запись в &amp;ldquo;affilates&amp;rdquo;. По логике работы mysql_dump, первой будет блокирована и сдамплена affilates. Записи в organisations можно вставлять только для уже существующих affilates, целосность данных не нарушается. После того, как affilates закончится и разблокируется, будет заблокирована logs. Как я уже писал, по условиям задачи она у нас большая и копируется, скажем, час (вполне реальный срок для большой таблицы). При этом никто не мешает создать запись в affilates, а потом из organisations сослаться на эту новую запись. Так, как упаковка affilates уже завершена - в дамп новая запись не попадет. После того, как мы упакуем organisations - в organisations образуются записи, ссылающиеся на не существовавшие в момент дампа ключи. И восстановить такой дамп без определенных магических движений будет невозможно. Ну и в качестве бонуса - мы потеряем данные, которые были созданы в процессе дампа, то есть целосность дампа будет на момент &lt;em>начала&lt;/em> операции, а не ее &lt;em>окончания&lt;/em>. Чтобы бороться со всеми этими проблемами и был придуман xtrabackup.&lt;/p>
&lt;h2 id="установка-и-настройка" >установка и настройка
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%b8-%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>xtrabackup - отдельный инструмент от компании percona. Из-за этого в большинстве штатных системных репозиториев он отсутствует - нужно ставить его из репозитория percona. Установка для debian и ubuntu:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">wget https://repo.percona.com/apt/percona-release_0.1-3.&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -sc&lt;span style="color:#66d9ef">)&lt;/span>_all.deb
dpkg -i percona-release_0.1-3.&lt;span style="color:#66d9ef">$(&lt;/span>lsb_release -sc&lt;span style="color:#66d9ef">)&lt;/span>_all.deb
apt-get update
apt-get install percona-xtrabackup&lt;/code>&lt;/pre>&lt;/div>
&lt;p>То же самое для RHEL-based (CentOS, RedHat, Fedora, ScientificLinux)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">yum install http://www.percona.com/downloads/percona-release/redhat/0.1-3/percona-release-0.1-3.noarch.rpm
yum clean all
yum makecache
yum install -y percona-xtrabackup&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Для удобства работы с xtrabackup (особенно, если хочется с его помощь делать резервные копии автоматически) рекомендуется создать файл-ответчик с паролем администратора сервера. Назовем его, к примеру, /root/.percona. Пример такого файла:&lt;/p>
&lt;pre>&lt;code>[client]
user=root
password=YYYYYYYY
&lt;/code>&lt;/pre>
&lt;h2 id="примерение" >Примерение
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%b8%d0%bc%d0%b5%d1%80%d0%b5%d0%bd%d0%b8%d0%b5">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;h3 id="простой-вариант---резервная-копия-всего-сервера-целиком" >Простой вариант - резервная копия всего сервера целиком:
&lt;span>
&lt;a href="#%d0%bf%d1%80%d0%be%d1%81%d1%82%d0%be%d0%b9-%d0%b2%d0%b0%d1%80%d0%b8%d0%b0%d0%bd%d1%82---%d1%80%d0%b5%d0%b7%d0%b5%d1%80%d0%b2%d0%bd%d0%b0%d1%8f-%d0%ba%d0%be%d0%bf%d0%b8%d1%8f-%d0%b2%d1%81%d0%b5%d0%b3%d0%be-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80%d0%b0-%d1%86%d0%b5%d0%bb%d0%b8%d0%ba%d0%be%d0%bc">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">innobackupex --rsync --defaults-file&lt;span style="color:#f92672">=&lt;/span>/root/.percona --no-timestamp /var/tmp/backup
innobackupex --rsync --defaults-file&lt;span style="color:#f92672">=&lt;/span>/root/.percona --no-timestamp --apply-log /var/tmp/backup&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Восстановление выглядит еще проще. Нужно просто остановить процесс mysql и положить файлы в datadir (обычно это /var/lib/mysql/), а затем - запустить mysql обратно. Перед запуском - обязательно сменить права доступа на файлы, чтобы файлами владел владелец процесса mysql:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">service mysql stop
rm -rf /var/lib/mysql/*
mv /var/tmp/backup/* /var/lib/mysql/
chown -R mysql:mysql /var/lib/mysql/
service mysql start&lt;/code>&lt;/pre>&lt;/div>
&lt;h3 id="усложненный-вариант---создаем-mysql-slave-от-имеющегося-мастера" >Усложненный вариант - создаем mysql slave от имеющегося мастера:
&lt;span>
&lt;a href="#%d1%83%d1%81%d0%bb%d0%be%d0%b6%d0%bd%d0%b5%d0%bd%d0%bd%d1%8b%d0%b9-%d0%b2%d0%b0%d1%80%d0%b8%d0%b0%d0%bd%d1%82---%d1%81%d0%be%d0%b7%d0%b4%d0%b0%d0%b5%d0%bc-mysql-slave-%d0%be%d1%82-%d0%b8%d0%bc%d0%b5%d1%8e%d1%89%d0%b5%d0%b3%d0%be%d1%81%d1%8f-%d0%bc%d0%b0%d1%81%d1%82%d0%b5%d1%80%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">&lt;span style="color:#75715e">#on master&lt;/span>
innobackupex --rsync --defaults-file&lt;span style="color:#f92672">=&lt;/span>/root/.percona --no-timestamp /var/tmp/backup
innobackupex --rsync --defaults-file&lt;span style="color:#f92672">=&lt;/span>/root/.percona --no-timestamp --apply-log /var/tmp/backup
rsync -rahP /var/tmp/backup NEW.SERVER.IP:/var/tmp/
&lt;span style="color:#75715e">#выдадим права для slave, чтобы он мог читать данные из master-сервера:&lt;/span>
mysql --defaults-file&lt;span style="color:#f92672">=&lt;/span>/root/.percona -Bse &lt;span style="color:#e6db74">&amp;#34;GRANT REPLICATION SLAVE ON *.* TO &amp;#39;replica&amp;#39;@&amp;#39;NEW.SLAVE.SEVER.IP&amp;#39; IDENTIFIED BY &amp;#39;XXXXXXXX&amp;#39;&amp;#34;&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>innobackupex создает специальный файл с информацией о текущем бинлоге и позиции в этом бинлоге. Эта информация необходима для подключения slave - чтобы slave мог знать, с какого точно момента в прошлом была сделана эта копия базы (и начал синхронизацию именно с нужного момента). Файл называется &lt;code>xtrabackup_binlog_info&lt;/code>. Содержимое у него выглядит примерно вот так:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">mariadb-bin.000003 &lt;span style="color:#ae81ff">642&lt;/span>&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Подключим slave-сервер к master-серверу. Для этого остановим mysql и подложим в datadir файлы, которые мы скопировали с master:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">service mysql stop
rm -rf /var/lib/mysql/*
mv /var/tmp/backup/* /var/lib/mysql/
chown -R mysql:mysql /var/lib/mysql
service mysql start&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Теперь подключим slave к master. Для этого в консоли mysql:&lt;/p>
&lt;pre>&lt;code>--- на всякий случай почистим остатки старой конфигурации slave.
--- В принципе их быть не должно.
STOP SLAVE;
RESET SLAVE;
--- настроим подключение к master
--- log_file и log_pos - из xtrabackup_binlog_info
CHANGE MASTER TO MASTER_HOST='NEW.MASTER.SERVER.IP',
MASTER_USER='replica',
MASTER_PASSWORD='YYYYYYYY',
MASTER_LOG_FILE='mariadb-bin.000003',
MASTER_LOG_POS=642;
--- запустим процесс репликации
START SLAVE
--- убедимся, что нет ошибок
SHOW SLAVE STATUS \G
&lt;/code>&lt;/pre>
&lt;h3 id="сложный-вариант---переносим-отдельную-таблицу" >сложный вариант - переносим отдельную таблицу
&lt;span>
&lt;a href="#%d1%81%d0%bb%d0%be%d0%b6%d0%bd%d1%8b%d0%b9-%d0%b2%d0%b0%d1%80%d0%b8%d0%b0%d0%bd%d1%82---%d0%bf%d0%b5%d1%80%d0%b5%d0%bd%d0%be%d1%81%d0%b8%d0%bc-%d0%be%d1%82%d0%b4%d0%b5%d0%bb%d1%8c%d0%bd%d1%83%d1%8e-%d1%82%d0%b0%d0%b1%d0%bb%d0%b8%d1%86%d1%83">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Искушающе простой способ (остановить mysql, подсунуть файлы с таблицей и запустить обратно) - не сработает, техника немного сложнее. Чтобы восстановить таблицу, нужно подготовить таблицу внутри резеврной копии к экспорту:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-shell" data-lang="shell">xtrabackup --prepare --export --target-dir&lt;span style="color:#f92672">=&lt;/span>/var/tmp/backup&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Теперь нужно создать таблицу с именем экспортируемой таблицы. Структура и содержимое не важны, важно только имя таблицы (имя базы тоже можно не учитывать):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sql" data-lang="sql">mysql&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">CREATE&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> ineedtorestore (a int(&lt;span style="color:#ae81ff">11&lt;/span>) &lt;span style="color:#66d9ef">DEFAULT&lt;/span> &lt;span style="color:#66d9ef">NULL&lt;/span>) ENGINE&lt;span style="color:#f92672">=&lt;/span>InnoDB &lt;span style="color:#66d9ef">DEFAULT&lt;/span> CHARSET&lt;span style="color:#f92672">=&lt;/span>latin1;
mysql&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> ineedtorestore DISCARD TABLESPACE;&lt;/code>&lt;/pre>&lt;/div>
&lt;p>Кстати, если при вводе второй таблицы выскочит ошибка &lt;code>ERROR 1030 (HY000): Got error -1 from storage engine&lt;/code>, то нужно включить в my.cnf настройку &lt;code>innodb_file_per_table&lt;/code>.&lt;/p>
&lt;p>Теперь нужно скопировать файлы с именем таблицы, которую мы будем восстанавливать, в каталог базы и перечитать файлы командой:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-sql" data-lang="sql">mysql&lt;span style="color:#f92672">&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">ALTER&lt;/span> &lt;span style="color:#66d9ef">TABLE&lt;/span> ineedtorestore IMPORT TABLESPACE;&lt;/code>&lt;/pre>&lt;/div>
&lt;p>После этого мы получим новую таблицу из бэкапа.&lt;/p></description></item></channel></rss>