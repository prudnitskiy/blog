<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>мониторинг on SRE Blog</title><link>https://prudnitskiy.pro/tags/%D0%BC%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3/</link><description>SRE Blog (мониторинг)</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Thu, 26 Nov 2015 16:21:06 +0000</lastBuildDate><atom:link href="https://prudnitskiy.pro/tags/%D0%BC%D0%BE%D0%BD%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3/index.xml" rel="self" type="application/rss+xml"/><item><title>Отслеживаем PHP с помощью PINBA на debian</title><link>https://prudnitskiy.pro/post/2015-11-26-pinba/</link><pubDate>Thu, 26 Nov 2015 16:21:06 +0000</pubDate><guid>https://prudnitskiy.pro/post/2015-11-26-pinba/</guid><description>&lt;p>PHP - исключительно популярный язык программирования, до сих пор огромное количество проектов пишется именно на нем. Язык ругают за отвратительный дизайн, неудобный синтаксис, кривое поведение в спорных случаях, отсутствие нормальных средств отладки - но его популярность это никак не снижает. Самое страшное для админа - ситуация, когда на сильно нагруженном проекте начинает тормозить код. Стандартные средства отладки (xprof, xdebug) роняют производительность языка в яму (накладные расходы - вплоть до пятикратного падения скорости), и как отлаживать сложный код на живую - совершенно неясно. Именно для борьбы с такими проблемами придумана PINBA - расширение для мониторинга скорости кода. Тут я расскажу, как установить PINBA (клиент, сервер и интерфейс) на debian и что с ними потом делать.&lt;/p>
&lt;h2 id="как-это-работает" >Как это работает
&lt;span>
&lt;a href="#%d0%ba%d0%b0%d0%ba-%d1%8d%d1%82%d0%be-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d0%b0%d0%b5%d1%82">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>В отличае от XProf PINBA практически не замедляет работу скрипта. В базовом варианте она не требует никакой модификации PHP кода и никак на его выполнение не влияет. Устройство очень простое, штатно PINBA состоит из двух частей. Во-первых - это PHP extenstion (pinba.so), который отслеживает время выполнения скрипта (а так же - адрес скрипта и URL, нагрузку на CPU, память и код завершения). По окончании выполнения запроса он отправляет данные на сервер pinba. Сервер - это MySQL, собранный со специальным плагином (libpinba.so). Сервер принимает на определенном порту UDP-датаграммы и складывает их в базу. Интерфейсом для чтения статистики служит MySQL, что позволяет сравнительно легко анализировать данные и писать к ним свои интерфейсы. Важно, что php extension (генератор) не проверяет целостность отправленных данных или качество их доставки - он просто считает и отправляет.&lt;/p>
&lt;p>Вот как будет выглядеть наша инсталляция:&lt;/p>
&lt;p>&lt;img src="https://prudnitskiy.pro/media/uploads/pinba.png" alt="https://prudnitskiy.pro/media/uploads/pinba.png" title="схема инсталляции">&lt;/p>
&lt;h2 id="установка-клиент" >Установка: клиент
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%ba%d0%bb%d0%b8%d0%b5%d0%bd%d1%82">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>В debian репозитории DotDeb есть нужный нам клиент (генератор статистики) и проще всего его прямо оттуда и поставить. Если у вас еще не установлен DotDeb - вот &lt;a href="https://www.dotdeb.org/instructions/" title="инструкция">инструкция&lt;/a>. После этого просто ставим пакет:&lt;/p>
&lt;pre>&lt;code>apt-get install -y php5-pinba
&lt;/code>&lt;/pre>
&lt;p>И настраиваем его, поправив файл /etc/php5/mods-available/pinba.ini&lt;/p>
&lt;pre>&lt;code>extension=pinba.so
pinba.enabled=1
pinba.server=172.16.10.10:30002
&lt;/code>&lt;/pre>
&lt;p>В этом примере предполагается, что сервер, собирающий статистику у нас имеет адрес 172.16.10.10 и порт 30002. После этого перезапускаем php и установка клиента на этом закончена.&lt;/p>
&lt;h2 id="установка-сервер" >Установка: сервер
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d1%81%d0%b5%d1%80%d0%b2%d0%b5%d1%80">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>С установкой сервера все несколько сложнее, так как пакет pinba-server есть только у dotdeb и он сломан. Его прийдется собирать из исходного кода. Для начала на сервер статистики поставим сам mysql. Это должен быть именно стандартный mysql, а не maria или percona:&lt;/p>
&lt;pre>&lt;code>apt-get install mysql-server-5.6 mysql-client-5.6 libmysqlclient18 libmysqlclient18-dev
&lt;/code>&lt;/pre>
&lt;p>Теперь поставим инструменты разработки, они потребуются нам, чтобы собрать пакет:&lt;/p>
&lt;pre>&lt;code>apt-get install build-essential protobuf-compiler libmysqlclient-dev \
libjudydebian1 libevent-dev libjudy-dev git libevent-2.0-5 libtool \
libevent-core-2.0-5 libevent-extra-2.0-5 libevent-openssl-2.0-5 \
libevent-pthreads-2.0-5 libprotobuf-dev libprotobuf-lite7 libprotobuf7 git-core
&lt;/code>&lt;/pre>
&lt;p>Переходим в tmp, выгружаем код pinba engine (сервер статистики) и исходный код mysql server:&lt;/p>
&lt;pre>&lt;code>cd /var/tmp
git clone 'https://github.com/tony2001/pinba_engine'
apt-get source mysql-server
&lt;/code>&lt;/pre>
&lt;p>Нам потребуется header-file от существующего mysql-сервера, скопируем. Я не знаю, какая версия mysql-server будет у вас, у меня это mysql-5.6-5.6.25.&lt;/p>
&lt;pre>&lt;code> cp '/usr/include/mysql/mysql_version.h' /var/tmp/mysql-5.6-5.6.25/include/
cp '/usr/include/mysql/my_config.h' /var/tmp/mysql-5.6-5.6.25/include/
&lt;/code>&lt;/pre>
&lt;p>Нам нужно узнать текущие опции сборки mysql:&lt;/p>
&lt;pre>&lt;code>OPTIONS=&amp;quot;$(VISUAL=\&amp;quot;$(which 'cat')\&amp;quot; mysqlbug | grep 'Configured with' | sed -e 's/.*configure -v //')&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Соберем модуль:&lt;/p>
&lt;pre>&lt;code>cd pinba_engine
./buildconf.sh
./configure ${OPTIONS} \
--with-mysql='${MYSQL_SOURCES}' \
--with-judy \
--with-protobuf \
--with-event \
--libdir='/usr/lib/mysql/plugin/'
make
make install
&lt;/code>&lt;/pre>
&lt;p>Библиотека собрана, теперь можно установить плагин на сервер и создать базу, где мы будем хранить статистику:&lt;/p>
&lt;pre>&lt;code>mysql --execute=&amp;quot;INSTALL PLUGIN pinba SONAME 'libpinba_engine.so';&amp;quot; --user=root
mysql --execute=&amp;quot;CREATE DATABASE pinba DEFAULT CHARACTER SET utf8 DEFAULT COLLATE utf8_unicode_ci;&amp;quot; --user=root
mysql --user=root 'pinba' &amp;lt; '/tmp/pinba_engine/default_tables.sql'
mysql --user=root --execute=&amp;quot;grant all on pinba.* to pinbauser@localhost identified by 'Hkx77jg8t6zGw6J5'&amp;quot;
&lt;/code>&lt;/pre>
&lt;p>Теперь сообщим серверу настройки pinba. Для этого поправим /etc/mysql/my.cnf. В секции [mysqld] добавим следующее:&lt;/p>
&lt;pre>&lt;code>pinba_port = 30002
pinba_address = 172.16.10.10
pinba_stats_gathering_period = 10000
pinba_stats_history = 900
pinba_temp_pool_size = 10000
pinba_request_pool_size = 10000
&lt;/code>&lt;/pre>
&lt;p>Чтобы изменения вступили в силу - надо перезапустить mysql. Разумеется, порт UDP/30002 не должен быть заблокирован в firewall. Настройка сервера на этом закончена, будемт ставить интерфейс.&lt;/p>
&lt;h2 id="установка-интерфейс" >Установка: интерфейс
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d1%84%d0%b5%d0%b9%d1%81">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Эту роль у нас будет выполнять Intaro&amp;rsquo;s pinboard. Интерфейс довольно простой, но удобный и симпатичный. В принципе, его можно поставить на любой сервер, с которого есть доступ к mysql, в моем примере это будет тот же сервер, куда мы собираем статистику. Для работы pinboard потребуется nginx, php5 (версии не менее 5.5) и php composer. Установим:&lt;/p>
&lt;pre>&lt;code>apt-get install -y php5-cli php5-common php5-curl php5-fpm php5-gd php5-mysql nginx-full
curl -sS https://getcomposer.org/installer | php
&lt;/code>&lt;/pre>
&lt;p>Выгрузим код:&lt;/p>
&lt;pre>&lt;code>cd /var/www
git clone git://github.com/intaro/pinboard.git --branch=v1.5.2
&lt;/code>&lt;/pre>
&lt;p>Установим зависимости:&lt;/p>
&lt;pre>&lt;code>cd pinboard
php composer.phar install
&lt;/code>&lt;/pre>
&lt;p>Чтобы интерфейс знал адрес и параметры соединения с базой, поправим настройки в файле &amp;lsquo;config/parameters.yml&amp;rsquo;:&lt;/p>
&lt;pre>&lt;code>db:
host: 127.0.0.1
name: pinba
user: pinbauser
pass: Hkx77jg8t6zGw6J5
&lt;/code>&lt;/pre>
&lt;p>остальное менять не нужно. Мигрируем базу:&lt;/p>
&lt;pre>&lt;code>./console migrations:migrate
&lt;/code>&lt;/pre>
&lt;p>Добавляем задание в крон для агрегации данных:&lt;/p>
&lt;pre>&lt;code>./console register-crontab
&lt;/code>&lt;/pre>
&lt;p>Теперь осталось настроить nginx. Для этого создадим файл /etc/nginx/sites-enabled/pinba со следующим содержанием:&lt;/p>
&lt;pre>&lt;code>server {
listen 80;
server_name pinba.ourdomian;
access_log /var/log/nginx/pinba.access.log;
error_log /var/log/nginx/pinba.error.log;
root /var/www/pinboard/web;
location = / {
try_files @site @site;
}
location / {
try_files $uri $uri/ @site;
}
location ~ \.php$ {
return 404;
}
location @site {
fastcgi_pass unix:///var/run/php5-fpm.sock;
include fastcgi_params;
fastcgi_param SCRIPT_FILENAME $document_root/index.php;
}
location ~ /\.(ht|svn|git) {
deny all;
}
}
&lt;/code>&lt;/pre>
&lt;p>Теперь достаточно просто перезапустить nginx и можно пользоваться нашим новым интерфейсом. Важно понимать, что статистика агрегируется раз в N минут (частоту спросит сам pinboard при миграции данных), но данные в секции live доступны в любой момент.&lt;/p></description></item><item><title>Мониторинг задержек при помощи smokeping</title><link>https://prudnitskiy.pro/post/2014-10-24-smokeping/</link><pubDate>Fri, 24 Oct 2014 10:48:00 +0000</pubDate><guid>https://prudnitskiy.pro/post/2014-10-24-smokeping/</guid><description>&lt;p>Как-то мне (в очередной раз) потребовалось настроить мониторинг доступности клиентского сервиса через интернет. В процессе настройки я обнаружил, что не смотря на существование очень простого, понятного и удобного инструмента под названием SmokePing, по нему практически нет документации на русском (а документация на английском очень ограничена и запрятана в странном месте). Поэтому я решил написать эту небольшую вводную статью.&lt;/p>
&lt;h2 id="о-чем-речь" >О чем речь
&lt;span>
&lt;a href="#%d0%be-%d1%87%d0%b5%d0%bc-%d1%80%d0%b5%d1%87%d1%8c">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>SmokePing - инструмент для мониторинга задержки во времени ответа. Изначально был написан для проверки качества сети (то есть - для провайдеров) - скачки в задержках и (особенно) потери пакетов демонстрируют потенциальные перебои в работе и вообще ничего хорошего означать не могут. В дальнейшем автор несколько расширил инструмент, и теперь он может следить за задержками, в принципе, в чем угодно, что может быть полезно разработчикам и админам высконагруженного проекта, который должен отвечать за заданный промежуток времени. Автор инструмента - широко известный в сисадминских кругах Тоби Этикер, тот самый, что придумал RRD (и следом - RRDTool), а затем - MRTG. Эти два инструмента используются, наверное, в 90% всех провайдерах услуг связи.&lt;/p>
&lt;h2 id="терминология-и-схема-работы" >Терминология и схема работы
&lt;span>
&lt;a href="#%d1%82%d0%b5%d1%80%d0%bc%d0%b8%d0%bd%d0%be%d0%bb%d0%be%d0%b3%d0%b8%d1%8f-%d0%b8-%d1%81%d1%85%d0%b5%d0%bc%d0%b0-%d1%80%d0%b0%d0%b1%d0%be%d1%82%d1%8b">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Сам по себе SmokePing устроен очень просто, если не сказать - примитивно. Изначально стартует один демон, который управляет всеми процедурами проверок. Для каждого способа проверки (название в терминах SP - Probe) стартует своя копия демона, которая отвечает за проверки именно этим способом. Раз в 5 минут демон проводит серию измерений и записывает результаты. Все результаты в &amp;ldquo;сыром виде&amp;rdquo; записываются в стандартный RRD (по одной RRD на каждый объект). Также в комплект поставки входит вебморда, которая отвечает за рисование графиков. Графики строго одиночные (комбинировать задержку с трех хостов на один график не дадут), но их можно масштабировать и двигаться в них по времени. Веб-интерфейс использует старый-добрый CGI, и вся эта конструкция написана на perl. SmokePing позволяет проводить измерения с нескольких разных машин (в терминах SP - Slave), но данные сгружать в одну точку для анализа. На борту имеется служба уведомлений, но все-таки это &amp;lsquo;не мониторинг&amp;rsquo;, это именно статистика качества ответов (как быстро пришел ответ и какой разлет в показателях).&lt;/p>
&lt;h2 id="установка" >Установка
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>В данном примере я рассматриваю Debian Linux, но SmokePing уверенно работает на практически любой ОС (требуется perl, librrd, желательно - fping, curl и dig).
Установка стандартная:&lt;/p>
&lt;pre>&lt;code>apt-get install smokeping
&lt;/code>&lt;/pre>
&lt;p>Если у вас еще нет вебсервера, нужен соответствующий, с поддержкой CGI. Я использовал lighttpd:&lt;/p>
&lt;pre>&lt;code>apt-get install lighttpd
&lt;/code>&lt;/pre>
&lt;p>Все настройки находятся в /etc/smokeping/config.d/&lt;/p>
&lt;ul>
&lt;li>Alerts - уведомления&lt;/li>
&lt;li>Database - место хранения данных. Трогать аккуратно!&lt;/li>
&lt;li>General - основные&lt;/li>
&lt;li>Presentation - внешний вид веб-морды (путь к шаблону веб-страницы, размеры графиков по умолчанию и тому подобное)&lt;/li>
&lt;li>Probes - способы мониторинга, подробнее ниже&lt;/li>
&lt;li>Slaves - дочерние зонды, которые позволяют мониторить загрузку из нескольких точек&lt;/li>
&lt;li>Targets - цели, которые мы мониторим&lt;/li>
&lt;/ul>
&lt;p>Сначала настроим основы. Самая важная настройка - предпоследняя. Если неправильно настроить URL - картинок с графиком не будет:&lt;/p>
&lt;pre>&lt;code>#/etc/smokeping/config.d/General
*** General ***
owner = Paul 'Logan' Rudnitskiy
contact = admin@DOMAIN
mailhost = mail.DOMAIN
cgiurl = httpa://monitoring.domain/smokeping/smokeping.cgi
syslogfacility = local0
&lt;/code>&lt;/pre>
&lt;p>Теперь настроим зонды (способы проверки):&lt;/p>
&lt;pre>&lt;code>#/etc/smokeping/config.d/Probes
*** Probes ***
+ FPing
binary = /usr/bin/fping
++ FPingNormal
offset = 0%
++ FPingLarge
packetsize = 5000
offset = 50%
&lt;/code>&lt;/pre>
&lt;p>В данном случае мы настроили две способа проверки одним зондом (FPing). Мы заранее определили путь к программе, которая проводит проверку (/usr/bin/fping), и можем проверять простыми пакетами или большими. графа offset нужна, чтобы не проверять один хост одновременно обычными и большими пакетами (это искажает результаты). Offset всегда в процентах и считается от начала цикла проверки.&lt;/p>
&lt;p>Добавим еще способов:&lt;/p>
&lt;pre>&lt;code>#/etc/smokeping/config.d/Probes
[...]
+ FPing6
binary = /usr/bin/fping6
+ DNS
binary = /usr/bin/dig
lookup = name.example
pings = 3
step = 60
offset = 10%
timeout = 2
+ Curl
binary = /usr/bin/curl
step = 60
timeout = 5
urlformat = http://%host%/
&lt;/code>&lt;/pre>
&lt;p>Теперь поподробнее, что тут появилось:&lt;/p>
&lt;ul>
&lt;li>pings - количество запросов за цикл проверки. По умолчанию 5, но это число можно менять&lt;/li>
&lt;li>step - длительность цикла проверки. Все проверки должны быть завершены за один цикл и записаны в базу. По умолчанию - 300sec (5 минуту)&lt;/li>
&lt;li>offset нам уже знаком&lt;/li>
&lt;li>timeout - тайм-аут в секундах&lt;/li>
&lt;li>lookup - специфичный параметр для плагина dig - какое имя нужно запрашивать на DNS&lt;/li>
&lt;li>urlformat - специфичный параметр для плагина curl. Подходит любой URL, который curl может обработать&lt;/li>
&lt;/ul>
&lt;p>Важно! Если вы меняете pings или step - вам прийдется пересоздать RRD-базу, так как изменить формат хранения данных в базе невозможно - он задается единожды и не может быть отредактирован. Соответственно, при изменении этой настройки вы потеряете статистику.&lt;/p>
&lt;p>Вооружившись probe-ами, создадим цели мониторинга:&lt;/p>
&lt;pre>&lt;code>#/etc/smokeping/config.d/Targets
*** Targets ***
#зонд из прошлого конфига
probe = FPingNormal
#верхушка меню. Меню поддерживают иерархию, очень удобно
+ network
menu = Network reachability
title = Network reachability (ICMP)
++ work
menu = Work
title = Work
+++ web1
menu = web1
title = web1
host = 10.0.0.1
+++ web2
menu = web2
title = web2
host = 10.0.0.2
#здесь мы будем мониторить время ответа веб-сервера
#зонд можно задать как для пункта меню (он наследуется по иерархии)
#и даже для отдельного хоста
#но нужно сначала задать зонд, и только потом - его настройки.
+ WEB
menu = web
title = web
probe = Curl
++ web1
menu = web1
title = web1
host = 10.0.0.1
# а это уже меню, потому, что мы проверяем не только HTTP
++ web2
menu = web2
title = web2
+++ web2www
menu = www
title = www
host = 10.0.0.2
+++ web2ftp
menu = www
title = www
host = 10.0.0.2
urlformat = ftp://%host%/pub/
&lt;/code>&lt;/pre>
&lt;p>Можно запускать smokeping, он уже будет собирать данные и сохранять статистику. Теперь хорошо бы на нее посмотреть. Настроим Lighttpd:&lt;/p>
&lt;pre>&lt;code>#/etc/lighttpd/conf-enabled/10-cgi.conf
server.modules += ( &amp;quot;mod_cgi&amp;quot; )
server.modules += ( &amp;quot;mod_setenv&amp;quot; )
$HTTP[&amp;quot;url&amp;quot;] =~ &amp;quot;^/smokeping&amp;quot; {
alias.url = (
&amp;quot;/smokeping/smokeping.cgi&amp;quot; =&amp;gt; &amp;quot;/usr/lib/cgi-bin/smokeping.cgi&amp;quot;
&amp;quot;/smokeping&amp;quot; =&amp;gt; &amp;quot;/usr/share/smokeping/www/&amp;quot;,
)
server.indexfiles = (&amp;quot;smokeping.cgi&amp;quot;)
#чтобы статистика была доступна только тем, кому можно ее смореть:
auth.backend = &amp;quot;htpasswd&amp;quot;
auth.backend.htpasswd.userfile = &amp;quot;/var/www/.htpasswd&amp;quot;
auth.require = ( &amp;quot;&amp;quot; =&amp;gt; (
&amp;quot;method&amp;quot; =&amp;gt; &amp;quot;basic&amp;quot;,
&amp;quot;realm&amp;quot; =&amp;gt; &amp;quot;icinga&amp;quot;,
&amp;quot;require&amp;quot; =&amp;gt; &amp;quot;valid-user&amp;quot;
) )
}
&lt;/code>&lt;/pre>
&lt;p>После перезапуска lighttpd можно открывать &lt;a href="http://monitoring.domain/smokeping">http://monitoring.domain/smokeping&lt;/a> и смотреть графики. В идеале надо подождать минут 30 (хотя бы), чтобы smping успел наполнить базу хоть какой-то статистикой.&lt;/p>
&lt;p>Вот так выглядит нормальный график:&lt;/p>
&lt;p>&lt;img src="https://prudnitskiy.pro/media/uploads/smokeping2.png?1" alt="График">&lt;/p>
&lt;p>А это график -курильщика- сервера, которому явно нехорошо&lt;/p>
&lt;p>&lt;img src="https://prudnitskiy.pro/media/uploads/smokeping3.png?1" alt="График курильщика">&lt;/p></description></item><item><title>Сравнение систем мониторинга</title><link>https://prudnitskiy.pro/post/2013-11-14-monitoring-comparsion/</link><pubDate>Thu, 14 Nov 2013 22:31:58 +0000</pubDate><guid>https://prudnitskiy.pro/post/2013-11-14-monitoring-comparsion/</guid><description>&lt;p>Мониторинг (отслеживание состояния сервисов), наряду с резеврным копированием является, наверное, одной из самых старых и популярных задач для системного администратора. Разумеется, существует великое множество различных инструментов для ее выполнения. В этом развесистом великолепии с трудом ориентируются даже бывалые специалисты. В данном тексте я собрал основные системы мониторинга с кратким описанием и сравнением плюсов, минусов и особенностей. Разумеется, статья не претендует на всеобъемлющее описание всех систем мониторинга планеты (их слишком много), но поможет хотя бы соориентироваться и понять, куда искать.&lt;/p>
&lt;h2 id="monit" >Monit
&lt;span>
&lt;a href="#monit">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Достаточно древняя разработка. Официальный слоган - That barking on daemons. Работает строго локально, самостоятельный демон, написан на C. Расширяемость нулевая - плагины не поддерживает. Основная задача - отслеживать работу демонов и перезапускать умершие, зависшие или вышедшие за квоту ресурсов. Обладает довольно своеобразным конфигом (не похож ни на что вообще). Не смотря на нулевую расширяемость в базе имеет большую часть необходимых проверок. Может проверять процесс по факту наличия, занимаемые ресурсы, подключаться к процессу (по сети или сокету), проверять ответ от сервера (на факт наличия, а так же на содержание), проверять соотвествие определенным протоколам (HTTP, FTP, POP/IMAP/SMTP - полный список смотреть в документации). Поддерживает работу с SSL, имеет встроенный веб-интерфейс. Проверка производится по расписанию, раз в определенное время. По результатам проверки может принимать определенные решения (прибить процесс, перезапустить, уведомить админа). Прост, надежен как автомат Калашникова. В активе компании-автора есть многосервисная платная система M/Monit - для управления группами сервров, но с ней я не сталкивался.&lt;/p>
&lt;h2 id="munin" >Munin
&lt;span>
&lt;a href="#munin">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Не смотря на то, что изначально этот проект создавался для рисования графиков, он может служить и мониторинговой системой (так, как имеет в базе систему уведомлений). Строго клиент-серверная система, на целевых узлах запускается процесс-клиент. Процесс-сервер подключается к клиентам по расписанию и собирает числовые данные (метрики), складирует их у себя и отрисовывает графики. Он же отвечает за уведомления - интеллект клиента у мунина близок к нулю. Легко расширяется: строго говоря, все метрики munin рисует, используя данные плагинов (без плагинов метрик не будет). Плагины легко пишутся - язык произвольный, так как мунин ожидает только числа (данные) метрик в определенном формате и код ответа. В силу своей архитектуры monit не способен производить действий на клиентских узлах (например - перезапускать зависший процесс). Язык написания самого демона - перл.&lt;/p>
&lt;h2 id="ganglia" >Ganglia
&lt;span>
&lt;a href="#ganglia">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Достаточно старый инструмент, созданный в CERN. Писали ученые и для ученых, а потому инструмент своеобразный. Основное назначение ганглии - сбор данных о производительности большого количества однотипных машин (вычислительные кластеры). Обладает производительностью, поражающей воображение (десятки тысяч наблюдаемых узлов на очень среднем сервере), но трешхолд довольно большой (данные собираются отложенно, так что если надо смотреть нагрузку в реальном времени - это не к нему. Клиент-серверная архитектура: клиент собирает данные, аккумулирует их у себя и раз в определенное время отсылает на сервер. В случае, если какая-то метрика перешагнула пороговое значение, ответ будет отправлен вне очереди. Сервер собирает данные со всех клиентов, аггрегирует их и сохраняет в базе. Веб-интерфейс живет отдельным компонентом, он связывается с сервером по внутреннему протоколу и отображает различные графики. В силу специфики ганглии интерфейс очень необычный, но прекрасно подходит для сравнительного анализа данных с групп серверов (например, построение графика зависимости нагрузки на CPU сервера 10 от сетевой нагрузки на сервера с 50 по 90 делается в два клика мышью). Ганглия расширяема, но написание плагина представляет из себя нетривиальную задачу - дело в том, что с точки зрения ганглии, плагин - это библиотека. Это накладывает требования на язык реализации плагина (только C или Python) и внутреннюю структуру кода (описано в документации). Сами демоны написаны на C, веб-интерфейс - на PHP. Обладает очень корявой системой уведомлений, чаще всего ганглию скрещивают с Исингой (см ниже)&lt;/p>
&lt;h2 id="nagios--icinga" >Nagios / Icinga
&lt;span>
&lt;a href="#nagios--icinga">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Довольно древний инстурмент, изначально назывался Nagios (автор - Этан Галстадт). В процессе разработки в стане разработчиков произошел раскол и появился форк (Icinga). Сейчас эти системы развиваются самостоятельно, но общего в них много больше, чем разницы. Nagios существует в бесплатной (core) и платной редакциях, Icinga - честный Open source. Изначально серверно-ориентированный демон на голом С, управление демоном ведется через C-подобный конфиг (внешне напоминает конфиг ISC BIND). Все проверки собираются в живую очередь и выполняются в строгой очередности. Это налагает определенные ограничения на масштабируемость - сервер удержит большое количество проверок без труда, но чем их больше, тем больше времени проходит между ними. По личному опыту, пара тысяч проверок (400 серверов х 5 проверок на сервер) делает систему мониторинга практически бессмысленной - между проверками проходит слишком много времени. В качестве опции существует приложение-клиент под названием NRPE, он позволяет проводить проверку локально, на клиенте (для тех случаев, когда проверить сервис удаленно невозможно), но это именно опция. Кроме того, проверки через клиента проводятся по инициативе сервера, так что на масштабируемость это никак не влияет. Nagios очень хорошо расширяется, плагины пишутся очень просто (и существует их великое множество). Nagios славится мощной и гибкой системой уведмолений - в базе она умеет писать письма и слать смс и сообщения на пейджер, но есть целый набор плагинов - от автоматического звонка голосом до светофора (не фигурально, а буквально - управляется эта радость через ModBus). Icinga имеет два веб-интерфейса на выбор - классический CGI и более современный на PHP. Субъективно CGI удобнее, хотя и менее гибок. Прародитель (nagios core) имеет только CGI-версию интерфейса. Важно отметить, что nagios не умеет и не желает собирать статистику ответов, соответственно ждать от нее красивых графиков в стиле Munin/Ganglia/Cacti бессмысленно. Существует мост для связи Icinga с Ganglia, это довольно популярный тандем, в котором Icinga отвечает, в первую очередь, за карту сети, обзор хостов и уведомления.&lt;/p>
&lt;h2 id="cacti" >Cacti
&lt;span>
&lt;a href="#cacti">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Изначально этот инструмент позиционируется для быстрой и простой сборки статистики по SNMP, но, с применением плагинов (notify + treshold) он обретает возможности системы монитоинга. Это PHP-приложение, настройки и конфигурации хранятся в базе MySQL (статистика хранится в RRD, что благотворно сказывается на производительности сервиса). Очень простая установка и первичная настройка (все делается через веб), в целом неплохо масштабируется (особенно, если применять костыли вида spine - многопоточного SNMP-опросника), большое количество базовых шаблонов для проверки различных типов устройств. Основной минус приложения - в его SNMP-центричности. Данный сервис хорошо подходит для сбора данных с активного оборудования, терпимо - для сбора типичной статистики работы сервиса (дисковое пространство, загрузка CPU etc) и отвратительно - для сбора сложных и нетипичных метрик. Кастомизация плохая.&lt;/p>
&lt;h2 id="opennms" >OpenNMS
&lt;span>
&lt;a href="#opennms">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Старший брат сервиса, рассмотренного выше. Это сложный, многокомпонентый &amp;ldquo;комбайн&amp;rdquo;, написанный на Java (собственный app-server, томкат не нужен), ориентированный на большие инфраструктуры с передачей статистики по SNMP. Большая сложность и гибкость сервиса превращают настройку в нетривиальное дело - для некрупных инфраструктур этот сервис явно избыточен. Так же, как и cacti, сервис придуман для работы с SNMP, а значит, основное применение сервиса - это мониторинг сетевых устройств. Сервис страдает практически полным отсутствием документации и очень плохо расширяем (по сути это монолитное java-приложение, внутренние настройки живут в виде неудобочитаемых XML-файлов, что превращает нетривиальную настройку в пытку).&lt;/p>
&lt;h2 id="graphite--collectd--whisper" >Graphite + CollectD + Whisper
&lt;span>
&lt;a href="#graphite--collectd--whisper">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Каждый компонент этого набора сам по себе не решает проблему мониторинга. Если все выше перечисленные продукты - это готовые решения уровня &amp;ldquo;сел и поехал&amp;rdquo;, то эта солянка больше напоминает мебель из IKEA (с той только разницей, что из этого набора с равной вероятностью можно собрать стол или подводную лодку). Фантастический неудобные файлы конфигурации, низкая стабильность кода (версии вида 0.1.192-alpha - нормальное дело) и тотальное отсутствие документации с лихвой компенсируется скоростью работы и масштабируемостью. Если вам надо собирать данные с серверной фермы класса github и видеть данные в практически реальном времени - вы нашли свой инструмент. Как и всякий молодой, сложный и специфичный инструмент - эта связка требует очень серьезной доработки до нужного состояния. Но. Эта штука работает быстро, действительно, &amp;lsquo;&amp;lsquo;невероятно&amp;rsquo;&amp;rsquo; быстро.&lt;/p>
&lt;h2 id="zabbix" >Zabbix
&lt;span>
&lt;a href="#zabbix">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Авторы этого инструмента при разработке брали примером серьезные системы мониторинга enterprice-класса. По сути - zabbix - это мониторинг enterprice-класса, но при этом он opensource. Обладает трехзвенной архитектурой (сервер-прокси-клиент, прокси опционален, но помогает снизить нагрузку), данные хранит в SQL, веб-интерфейс - полностью самостоятельное приложение на php. Сами демоны мониторинга написаны на C/C++. Все настройки так же хранятся в базе данных, а меняются через веб. Система обладает на редкость развесистым функционалом и покрывает любые, даже самые безумные &amp;ldquo;хотелки&amp;rdquo;. Множество различных проверок, графики &amp;ldquo;от чего угодно и куда угодно&amp;rdquo;, эскалации проблем и отслеживание SLA, app-level проверки, имитация хождения пользователя по сайту (с поддержкой javascript, cookies, GET/POST/PUT), карты и схемы, настраиваемые панели (dashboards) с любыми метриками на выбор. Система имеет свой API, распределенную модель прав доступа, умеет кластеризоваться для снижения нагрузки на узлы, умеет шаблоны проверок. В отличае от большинства перечисленных выше систем, zabbix может производить действия на клиентах (например - перезапустить определенный процесс), что дает множество интересных перспектив. Система прекрасно расширяется и очень гибко настраивается. Разумеется, не обходится и без дегтя, и главный бочонок сидит в SQL. Дело в том, что в SQL заббикс хранит абсолютно все - настройки, статистику, метрики, узлы. Активно работающий zabbix выедает IOPS с поражающей воображение скоростью, админы судорожно пьют корвалол и читают database performance optimization guides (что помогает, впрочем, мало) - или молятся на свой data storage. Несколько помогает снижение количество метрик и частоты их сбора, но это снижает пользу самой системы мониторинга (какой смысл в системе мониторинга, если она не мониторит?). Дополнительная пара ложек дегтя прячется в сложности zabbix. Черезвычайно гибкая по сути, система очень непроста в установке (даже с учетом того, что у нее прекрасно написана документация, в ней освещены практически все вопросы). Внедрение заббикса с нуля свободно может занять месяц труда администратора, а оптимизация под задачи бизнеса и вовсе процесс практически вечный. В целом - это хороший вариант для крупного бизнеса, которому нужны специфичные метрики (и который готов платить за столь масштабное внедрение). Затратив прорву времени, сил и денег (на оборудование), босс получает возможность одним взглядом окинуть всю инфраструктуру и сразу понять, где проблема.&lt;/p></description></item><item><title>Использование Munin</title><link>https://prudnitskiy.pro/post/2011-11-21-munin-install/</link><pubDate>Mon, 21 Nov 2011 05:07:29 +0000</pubDate><guid>https://prudnitskiy.pro/post/2011-11-21-munin-install/</guid><description>&lt;p>В данной статье рассматривается такой инструмент мониторинга, как Munin. Этот инструмент существует под xNIX (Linux, xBSD, Solaris) и Windows и позволяет централизовано отслеживать и наглядно отображать состояние подшефных систем. Изначально используется для отрисовки графиков, но также его можно использовать как чистое средство для наблюдения. Большой плюс Munin - гибкость (все графики рисуются плагинами, активными на целевых системах, и никто не запрещает использовать только те плагины, которые нужны) и возможность с одного сервера собирать информацию о множестве других. Соответственно, нагрузка на наблюдаемом сервере минимальна. Интересно? Добро пожаловать под кат&lt;/p>
&lt;h2 id="что" >Что?
&lt;span>
&lt;a href="#%d1%87%d1%82%d0%be">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Munin - достаточно не новая система, развившаяся на популярном среди администраторов средстве отрисовки графиков RRDTool. Напомню, что идеология RRDTool состоит в хранении данных по &amp;ldquo;карусельному&amp;rdquo; типу - при заполнении базы фиксированного размера RRDTool начинает затирать данные с хвоста базы (то есть со старых) к голове (к новым), что гарантирует потерю минимального количества полезных данных, но при этом позволяет базе не распухать до безумных размеров (как у HP OpenView или Zabbix). Обычно в базе RRDTool есть несколько каруселей - например &amp;ldquo;мгновенные данные&amp;rdquo; (хранятся неделю), среднее за 5 минут (генерируется на основе мгновенных данных, хранятся месяц) и средние за час (генерируются на основе 5минутных, хранятся год. Такая база весит всего несколько мегабайт, и в размерах никогда не меняется (если данных в базе нет, в хвосте карусели просто стоят нули, слоты в базе под данные создаются сразу все). Минус RRDTool в его же плюсе. Нужно очень внимательно расчитывать емкость базы, потому что отредактировать созданную базу уже невозможно, и вытащить данные с целью перенести в другую базу (аналог DUMP в SQL базах) - тоже. Кроме того, RRDTool отвечает только за &lt;strong>хранение&lt;/strong> данных, а их ведь еще откуда-то надо брать&amp;hellip; Изначально админы использовали для этого самописные скрипты &amp;ldquo;на чем печень возжелает&amp;rdquo;, традиционно первые места занимали всесущий Bash и мозголомный Perl (в последнем даже присуствует расширение для работы с RRD, остальные языки вынуждены использовать &amp;ldquo;подпорки&amp;rdquo; в виде вызова rrdtool прямиком из командной строки). Скрипты у всех были разные, качество кода и оптимизация работы таких скриптов гуляла в широчайших пределах. Сам я, на самой заре своей админской карьеры, писал подобные скрипты, причем писал &amp;ldquo;в лоб&amp;rdquo;, простенький скрипт на пяток параметров мог выполнятся несколько секунд. Разумеется, в случае, когда возникает потребность (в инструменте удобного рисования графиков) - возникает и инструмент. Именно таким инструментом стал проект Munin.&lt;/p>
&lt;h3 id="обзор-и-архитектура" >Обзор и архитектура
&lt;span>
&lt;a href="#%d0%be%d0%b1%d0%b7%d0%be%d1%80-%d0%b8-%d0%b0%d1%80%d1%85%d0%b8%d1%82%d0%b5%d0%ba%d1%82%d1%83%d1%80%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Munin состоит из двух раздельных частей. Первая - это сервер (собственно, munin) - он опрашивает клиентов, хранит базу и рисует графики. Вторая - клиент (munin-node). Соединение с клиентом всегда инициирует сервер (он запускается по cron). При запуске сервер читает конфиг со списком адресов клиентов, обращается к каждому клиенту (порт - 4949/tcp), получает список возможных параметров, после чего - по списку - значения параметров. Полученые данные загружаются в RRD-файлы (если таковых нет - сервер их создаст). Рисованием готовых графиков ведает отдельный процесс, который хоть и входит в пакет munin, но живет совершенно самостоятельной жизнью.&lt;/p>
&lt;p>В отличае от сервера, клиент - это постоянно находящийся в памяти демон. Написан он, как и сервер, на чистом perl. К слову сказать, единственный способ авторизации - IP, с которого инициируется соединение. Шифрования там также никакого, так что светить демона не советую, firewall и внимательную настройку конфига никто не отменял. Интересный факт, но сам демон ничего не знает о системе, в которой находится. Данные, которые клиент отдает серверу, он получает от плагинов-программ, которые последовательно запускает. За счет этого оптимизируется нагрузка на сервер (всегда можно оставить только те плагины, которые нужны), и вместе с тем - уменьшается время простоя демона, который уже не должен мучительно выдумывать параметры, которых в данной конкретной системе отродясь не бывало.&lt;/p>
&lt;h2 id="как" >Как
&lt;span>
&lt;a href="#%d0%ba%d0%b0%d0%ba">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;h3 id="установка-и-диагностика" >Установка и диагностика
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%b8-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Как я уже упомниал выше, munin состоит из двух пакетов. Ставятся они тривиально, но нужно быть готовым к тому, что munin (сервер) потащит за собой немалую гору пакетов, отвечающих за RRD и графику (GD). Если мониторить надо один сервер - надо ставить оба пакета (пример для debian):&lt;/p>
&lt;pre>&lt;code>apt-get install munin munin-node
&lt;/code>&lt;/pre>
&lt;p>В отличае от monit, munin не может выполнять никаких действий в системе (кроме сбора статистики), как следствие - его можно запускать сразу после установки. В Debian GNU/Linux и CentOS демон запускается сам:&lt;/p>
&lt;pre>&lt;code>lab:~# ps ax | grep muni
16139 ? Ss 0:00 /usr/sbin/munin-node
&lt;/code>&lt;/pre>
&lt;p>Активация плагинов сделана также просто и незатейливо - в папке с настройками munin (в linux это /etc/munin, а во freebsd - /usr/local/etc/munin) есть папка plugins. Все плагины, присутствующие в папке на момент запуска munin-node считаются активными. Если присутствующий плагин по какой-то причине отказывается работать (например, плагин сбора данных о MySQL при остановленом сервисе mysqld) - node вернет 0 при попытке получения информации из плагина.
На самом деле, все доступные плагины лежат обычно в другом месте, а в эту папку сложены симлинки.
Вот пример:&lt;/p>
&lt;pre>&lt;code>lab:~# ls -al /etc/munin/plugins/
total 2
drwxr-xr-x 2 root root 1024 2009-06-21 15:31 .
drwxr-xr-x 5 root root 1024 2010-02-11 23:35 ..
lrwxrwxrwx 1 root root 29 2009-05-19 16:39 acpi -&amp;gt; /usr/share/munin/plugins/acpi
lrwxrwxrwx 1 root root 28 2009-03-22 22:51 cpu -&amp;gt; /usr/share/munin/plugins/cpu
lrwxrwxrwx 1 root root 27 2009-03-22 22:51 df -&amp;gt; /usr/share/munin/plugins/df
...
&lt;/code>&lt;/pre>
&lt;p>Изначально с munin поставляется немлое количество плагинов (обращаю внимание - активны не все!), кроме того, есть сайты, где также выложены плагины. Кроме того, существует руководство по написанию плагинов самостоятельно, но эта тема уже заметно выходит за рамки статьи.
Некоторые плагины поддерживают аргументы вызова. Вот яркий пример:
Реальные файл плагина&lt;/p>
&lt;pre>&lt;code>-rwxr-xr-x 1 root root 4775 2009-11-25 13:38 if_
-rwxr-xr-x 1 root root 3164 2009-11-25 13:38 if_err_
А вот что лежит в конфигурационной директории:
lab:~# ls -al /etc/munin/plugins/ | grep if
root root 32 2009-03-22 22:51 if_err_eth0 -&amp;gt; /usr/share/munin/plugins/if_err_
root root 32 2009-03-22 22:51 if_err_eth1 -&amp;gt; /usr/share/munin/plugins/if_err_
root root 28 2009-03-22 22:51 if_eth0 -&amp;gt; /usr/share/munin/plugins/if_
root root 28 2009-03-22 22:51 if_eth1 -&amp;gt; /usr/share/munin/plugins/if_
root root 28 2009-06-21 15:31 if_tun0 -&amp;gt; /usr/share/munin/plugins/if_
&lt;/code>&lt;/pre>
&lt;p>Без аргументов подобные плагины вызывать бесполезно - они не будут понимать, чего от них хотят.&lt;/p>
&lt;p>Некоторые плагины поддерживают дополнительные настройки. Например, для плагина, собирающего информацию о MySQL можно задать логин и пароль для входа на сервер. Подобные настройки munin хранит в файле {confdir}/plugin-conf.d/munin-node.&lt;/p>
&lt;p>Файл довольно подробно прокомментирован, но я, на всякий случай, приведу тут пару примеров:&lt;/p>
&lt;pre>&lt;code>#информация для плагина APT
[apt]
#запускать от имени root. В противном случае APT не запускается
user root
#информация для всех плагинов множества smart_,
#эти плагины вызываются по принципу smart_{DISK}
[smart_*]
#опять же, только root сможет прочитать параметры из smartctl
user root
#информация для плагина postgres_queries, база mngsearch
[postgres_queries_mngsearch]
#env.{имя} у каждого плагина могут быть своими.
#Подробно надо смотреть в source-коде плагина
#в данном примере мы задаем имя пользователя и пароль
#для получения данных о работе базы mngsearch
env.PGUSER mngsearch
env.PGPASSWORD Yn2ajPV4f6V5rzqj
&lt;/code>&lt;/pre>
&lt;p>Как можно убедится из примера выше, синтаксис файла очень несложный.&lt;/p>
&lt;h3 id="пошаговые-инструкции" >пошаговые инструкции
&lt;span>
&lt;a href="#%d0%bf%d0%be%d1%88%d0%b0%d0%b3%d0%be%d0%b2%d1%8b%d0%b5-%d0%b8%d0%bd%d1%81%d1%82%d1%80%d1%83%d0%ba%d1%86%d0%b8%d0%b8">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Сворачиваем растекание мыслью по древу. Теперь - четкие и понятные пошаговые инструкции.
Установка пакетов производится средствами ОС, собирать их из SRC не советую. Рассмотрим ситуацию, когда наблюдатель и наблюдаемый - физически одна машина.
Для начала настроим клиент:&lt;/p>
&lt;pre>&lt;code>vi /etc/munin/munin-node.conf
...
log_level 4
#&amp;quot;говорливость&amp;quot; munin в журнале. 10 - режим отладки, 1 - полная тишина
log_file /var/log/munin/munin-node.log
#путь к журналу. Должен уже существовать
pid_file /var/run/munin/munin-node.pid
#pid-file, менять без необходимости не советую
background 1
#режим демона. Для отладки ставим 0 - и нод будет вечно висеть на консоли
setseid 1
user root
group root
#имя владельца процесса.
#У него должны быть права на получение ID каждого имени пользователя,
#от имени которых запускается плагин проверки
#лучше пусть root и остается
setsid yes
#выставлять ID пользователя для каждого плагина. Трогать не советую
allow ^127\.0\.0\.1$
#с какого IP придет запрос сервера. В нашем случае - 127.0.0.1
#обращаю ваше внимание на то, что это регулярное выражение (RegExp).
host 127.0.0.1
#к какому IP привязывать демон. В данном примере - к 127.0.0.1
port 4949
#соовтвественно, порт.
&lt;/code>&lt;/pre>
&lt;p>Изменение конфига или списка плагинов требует перезапуска демона. При изменении списка плагинов нужно именно перезапускать демона, kill -HUP в данной ситуации не поможет.&lt;/p>
&lt;p>Проверяем работу демона:&lt;/p>
&lt;pre>&lt;code>lab:/etc/munin# telnet 127.0.0.1 4949
Trying 127.0.0.1...
Connected to 127.0.0.1.
Escape character is '^]'.
# munin node at lab.local.logan
list
open_inodes ip_127.0.0.1 postgres_queries_mngsearch irqstats
if_eth0 squid_cache sensors_temp df tor_connections swap
load cpu df_inode smart_hda forks iostat sensors_fan open_files
memory postgres_queries_netams exim_mailqueue vmstat sensors_volt
if_err_eth0 entropy processes acpi interrupts mysql_bytes if_tun0 if_err_eth1
if_eth1 tor_traffic exim_mailstats
fetch ip_127.0.0.1
in.value 83599135
out.value 83599135
.
quit
Connection closed by foreign host.
&lt;/code>&lt;/pre>
&lt;p>Командной list мы получили список активных плагинов, командой fetch - получили данные из одного плагина. Демон мониторинга ведет себя точно также, что позволяет с высокой степенью достоверности убедится в правильности работы клиента-нода.&lt;/p>
&lt;p>Теперь переходим к серверу. В отличае от клиента (нода) - сервер не существует как процесс, он запускается только в моменты получения данных и рисования графиков (и то не всегда, этот вопрос будет рассмотрен ниже)
В списке процессов выглядит это вот так:&lt;/p>
&lt;pre>&lt;code>lab:~# ps ax | grep muni
16139 ? Ss 0:00 /usr/sbin/munin-node
17842 ? S 0:00 /bin/sh /usr/bin/munin-cron
17843 ? S 0:00 /usr/bin/perl -w /usr/share/munin/munin-update
17846 ? S 0:00 /usr/share/munin/munin-update [r1sz.zooclub.ru]
17847 ? S 0:00 /usr/share/munin/munin-update [web1.zooclub.ru]
17848 ? S 0:00 /usr/share/munin/munin-update [monitor-01.infobox.ru]
17849 ? S 0:00 /usr/share/munin/munin-update [stat.kpp.ru]
17851 ? S 0:00 /usr/share/munin/munin-update [ro2-h.local]
17852 ? S 0:00 /usr/share/munin/munin-update [ro1-h.local]
17853 ? S 0:00 /usr/sbin/munin-node
&lt;/code>&lt;/pre>
&lt;p>Настройки демона находятся в файле {config}/munin.conf
Он также очень подробно откомментирван, и ниже я приведу минимальный работоспособный пример.&lt;/p>
&lt;pre>&lt;code>dbdir /home/db/monitor
#место, где хранятся RRD. Путь должен существовать, а rrd демон создаст сам
htmldir /home/www/mon
#куда выкладывать готовые графики
logdir /var/log/munin
#где лежат логи
rundir /var/run/munin
#Описания серверов
[lab.local]
address 127.0.0.1
use_node_name yes
#эта директива нужна, на страничке с графиками отображалось имя узла, а не его адрес.
[midori.local]
#другой сервер, в той же группе
address 10.9.8.7
use_node_name yes
[web2.zooclub.ru]
#сервер в другой группе
address 77.221.150.98
use_node_name yes
contact.logan.command mail -s &amp;quot;Munin notification&amp;quot; logan@mydomain.my
#слать сообщения об ошибках.
#Информацию об ошибке сервер принимает от клиента.
#Изменение статуса (ОК&amp;lt;-&amp;gt;ОШИБКА) будет сопровождатся письмом
#graph_strategy cgi
#можно использовать CGI для отрисовки графиков вместо отрисовки по крону.
#Это уменьшает нагрузку на сервер, если графики смотрят редко.
#Если графики смотрят часто (или много народу) - вы уложите сервер.
&lt;/code>&lt;/pre>
&lt;p>Указаных выше настроек вполне хватит для нормальной работы. Более подробно эти настройки указаны в документации, но ждать многого от munin не надо - это полезный, но очень простой и ограниченый инструмент.&lt;/p>
&lt;h3 id="обслуживание" >Обслуживание
&lt;span>
&lt;a href="#%d0%be%d0%b1%d1%81%d0%bb%d1%83%d0%b6%d0%b8%d0%b2%d0%b0%d0%bd%d0%b8%d0%b5">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Munin имеет простейшее устройство, строго в рамках unix-way. Периодического обслуживания он не требует, а непереодическое - осуществляется очень просто. Разберем основные случаи:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Жрет процессор и/или рисует графики с разрывами. Важно - Разрывы в рамках одной ноды на графиках расположены по-разному. Основная причина - не успевает отрабатывать процесс рисования (munin-graph). Надо либо уменьшить количество параметров, которые munin получает с нод (удалив там неиспользуемые плагины), либо перенастроить munin на fcgi режим (графики будут отрисованы при обращении), либо переезжать на другую машину.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>График не рисуется совсем или не обновляется. Проблема в правах доступа на папку, куда munin-graph складывает графики. По умолчанию владелец папки должен быть munin, права на запись, чтение и вхождение в папку у него должны быть. Узнать, кто точно владеет папкой, поможет команда&lt;/p>
&lt;p>ps auxww | grep graph&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Как мигрировать munin server (вариант - сделать резервную копию). Чтобы перенести munin - достаточно перенести папку dbdir из конфигурации. Точно соблюдать версию при переносе не обязательно, munin очень давно не меняет структуру баз при обновлении версии. Папки с графиком переносить совершенно не обязательно, munin всегда рисует графики с нуля, основываясь на данных из базы.&lt;/p>
&lt;/li>
&lt;/ul></description></item><item><title>Monit - наблюдатель за системными процессами</title><link>https://prudnitskiy.pro/post/2011-06-23-monit-howto/</link><pubDate>Thu, 23 Jun 2011 08:16:22 +0000</pubDate><guid>https://prudnitskiy.pro/post/2011-06-23-monit-howto/</guid><description>&lt;p>Monit - самостоятельный демон, работающий от пользователя root. Демон работает на Linux, Free/Net/OpenBSD, SUN Solaris и некоторых других UNIX-системах. Это OpenSource проект, у которого есть &amp;ldquo;старший брат&amp;rdquo; - коммерческий проект MMonit. Последний обладает более широким функционалом в вопросе массового мониторинга, межсетевого взаимодействия и составления отчетов. Идея авторов проста - для одиночного сервера используем Monit, для большой сетевой фермы - MMonit.&lt;/p>
&lt;p>В зависимости от настроек, демон может проверять:&lt;/p>
&lt;ul>
&lt;li>Существование процесса по PID&lt;/li>
&lt;li>Работу определенного порта (TCP/UDP)&lt;/li>
&lt;li>Ответ определенного протокола по определенному порту (SMTP, SSH, HTTP&amp;hellip;)&lt;/li>
&lt;li>Ресурсы, занимаемые процессом (CPU time/RAM)&lt;/li>
&lt;li>MD5 checksum&lt;/li>
&lt;li>Объем и свободное пространство в файловой системе&lt;/li>
&lt;li>Количество активных (и суммарное) i-node-в&lt;/li>
&lt;li>Права доступа к файлу или каталогу&lt;/li>
&lt;/ul>
&lt;p>Никто не запрещает комбинировать различные методы проверки. Для одного объекта проверки (тесты) зависят друг от друга, то есть сначала проводится тест1, если он прошел без ошибок - тест2, затем - тест3 и т.д.&lt;/p>
&lt;p>В случае, если какой-то тест не пройден, monit может:&lt;/p>
&lt;ul>
&lt;li>Остановить, стартовать или перезапустить демона&lt;/li>
&lt;li>Подождать определенное время&lt;/li>
&lt;li>Уведомить админа (почтовым сообщением)&lt;/li>
&lt;li>Примонтировать, отмонтировать или перемонтировать файловую систему&lt;/li>
&lt;li>Запустить отдельный скрипт (заранее написаный админом), причем передать ему определенные параметры (имя процеса/текст ошибки и т.д.)&lt;/li>
&lt;/ul>
&lt;p>Действия также никто не запрещает комбинировать, например:
Если HTTPd занимает более 200 мегабайт - ждать минуту, если ничего не изменилось - перезапустить сервис, если это также не помогло - прождать пять минут. Если и это не помогло - остановить сервис и уведомить админа письмом.&lt;/p>
&lt;p>И еще. У Monit есть собственный http-сервер. Злоупотреблять им не стоит, так как работает он с рутовыми привелегиями, но иметь доступ к веб-консоли может быть крайне полезным. Вебсервер будет рассмотрен отдельно, в этой же статье.&lt;/p>
&lt;h2 id="установка-и-настройка" >Установка и настройка
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%b8-%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Монит есть практически во всех широко распространенных дистрибутивах. В Debian, CentOS и Suse он так и называется. Во FreeBSD лежит в {PORTS}/sysmgmt/monit. Ставится он стандартным для операционной системы способом, и я не буду на нем остонавливатся.
Результатом установки будет собственно демон (monit) и файл конфигурации, который живет тут:&lt;/p>
&lt;pre>&lt;code># Linux, Solaris:
/etc/monit/monitrc
# FreeBSD/OpenBSD/NetBSD
/usr/local/etc/monit/monitrc
&lt;/code>&lt;/pre>
&lt;p>Конфиг очень подробно документирован, его рекомендуется почитать. Там есть подробные примеры и вообще много чего интересного. В принципе большую часть дефолтных настроек можно не трогать, ограничившись только необходимыми изменениями:&lt;/p>
&lt;pre>&lt;code># процесс работает как демон, цикл проверки - 120 секунд.
# длительность цикла можно менять, это основная еденица времени для monit.
# Раз в цикл срабатывают проверки и выполняются команды от админа,
# присланые через веб-интерфейс
set daemon 120
# сервера, через которые пойдет почтовое уведомление.
# Можно делать несколько, очередность срабатывания повторяет очередность внесения
set mailserver mail.zooclub.ru 10025,
localhost
# кто получит уведомление?
set alert sysadmin@zooclub.ru
&lt;/code>&lt;/pre>
&lt;p>Информацию о том, что monit должен проверять, можно хранить и в отдельном файле (файлах), которые подключаются в основной конфиг командой include:&lt;/p>
&lt;pre>&lt;code># один файл
include /etc/devel/monitcheck.monitconf
# все файлы с расширением из папки.
include /etc/stable/monit/*
&lt;/code>&lt;/pre>
&lt;p>Мне кажется, что удобнее хранить проверку каждого сервиса в отдельном файле - это облегчает отладку и упрощает администрирование.&lt;/p>
&lt;p>Мониторим состояние сервера в целом:&lt;/p>
&lt;pre>&lt;code>check system ws1.zooclub.ru
if loadavg (1min) &amp;gt; 4 then alert
if loadavg (5min) &amp;gt; 2 then alert
if memory usage &amp;gt; 75% then alert
if cpu usage (user) &amp;gt; 90% then alert
if cpu usage (system) &amp;gt; 40% then alert
if cpu usage (wait) &amp;gt; 20% then alert
&lt;/code>&lt;/pre>
&lt;p>Файловые системы:&lt;/p>
&lt;pre>&lt;code># /etc/stable/monit/filesystem.conf
# проверяем устройство по точке монтирования.
# Можно проверять диски напрямую (/dev/hda).
# C LVM и прочими логическими &amp;quot;дисками&amp;quot; этот фокус не прокатит,
# их проверять можно только по точке монтирования и никак иначе.
check device homefs with path /home
start program = &amp;quot;/bin/mount /home&amp;quot;
stop program = &amp;quot;/bin/umount /home&amp;quot;
if failed permission 755 then alert
if failed uid root then alert
# Если места остается меньше 20% минимум пять проверок за последние 15
# бить в набат и больше ничего не делать.
# При любой своей активности monit будет предупреждать админа письмом.
if space usage &amp;gt; 80% for 5 times within 15 cycles then alert
# Место кончилось, отмонтировать файлсистему
if space usage &amp;gt; 99% then stop
# аналогично про i-nodes.
if inode usage &amp;gt; 80% then alert
if inode usage &amp;gt; 99% then stop
group server
check device rootfs with path /
start program = &amp;quot;/bin/mount /&amp;quot;
# Потерять / во время работы сервера - безрадостная перспектива.
# По этому если дело плохо - просто перемонтируем его в read-only
stop program = &amp;quot;/bin/mount -o remount,ro /&amp;quot;
if failed permission 755 then unmonitor
if failed uid root then unmonitor
if space usage &amp;gt; 80% for 5 times within 15 cycles then alert
if space usage &amp;gt; 99% then stop
if inode usage &amp;gt; 80% then alert
if inode usage &amp;gt; 99% then stop
group server
check device bootfs with path /boot
start program = &amp;quot;/bin/mount /boot&amp;quot;
stop program = &amp;quot;/bin/mount -o remount,ro /boot&amp;quot;
# эта конструкция &amp;quot;отключит&amp;quot; тестирование файлсистемы, если права на папку - не 755
if failed permission 755 then unmonitor
if failed uid root then unmonitor
if space usage &amp;gt; 80% for 5 times within 15 cycles then alert
if space usage &amp;gt; 99% then stop
if inode usage &amp;gt; 80% then alert
if inode usage &amp;gt; 99% then stop
group server
&lt;/code>&lt;/pre>
&lt;p>Теперь проверим работу веб-сервера apache:&lt;/p>
&lt;pre>&lt;code># /etc/stable/monit/apache.conf
# проверка файла (размер, права доступа и тп):
check file apache_bin with path /usr/local/apache/bin/httpd
if failed checksum and
# sum - это стандартный md5-хэш.
# Его можно получить, натравив программу md5sum на нужный файл
expect the sum 8f7f419955cefa0b33a2ba316cba3659 then unmonitor
if failed permission 755 then unmonitor
if failed uid root then unmonitor
if failed gid root then unmonitor
# отдельное письмо на отдельный адрес и с отдельным содержимым.
alert security@zooclub.ru on {
checksum, permission, uid, gid, unmonitor
} with the mail-format { subject: Alarm! }
group server
# проверка процесса осуществляется по pid-файлу. Путь к pid-файлу всегда абсолютный
check process apache with pidfile /var/run/apache2.pid
start program = &amp;quot;/etc/init.d/apache2 start&amp;quot;
stop program = &amp;quot;/etc/init.d/apache2 stop&amp;quot;
if cpu &amp;gt; 60% for 2 cycles then alert
# если вебсервер сожрал 80% процессрного времени
# и не отдает его пять циклов проверки подряд - рестартуем его
if cpu &amp;gt; 80% for 5 cycles then restart
# аналогично по суммарной памяти, которую он поглотил.
if totalmem &amp;gt; 500.0 MB for 5 cycles then restart
if children &amp;gt; 250 then restart
# если load average сервера за 5 минут больше 10 8 циклов подряд - вырубаем.
if loadavg(5min) greater than 10 for 8 cycles then stop
# вот тут самое интересное - многоэтапная проверка:
# первый шаг - подключение на 80 порт, протокол http
if failed host 127.0.0.1 port 80 protocol http
# если получилось - запрашиваем файл /index.html
and request &amp;quot;/index.html&amp;quot;
with timeout 15 seconds
# а если что-то из цепочки не получилось - рестартуем демон
then restart
# проверка HTTP-SSL.
# Монит отдельно рассматривает SSL, и отдельно - защищаемый протокол.
# Для того, чтобы иметь возможность проводить такие проверки -
# нужно собрать monit с поддержкой SSL.
# Любители FreeBSD - будьте внимательны при сборке!
if failed port 443 type tcpssl protocol http
and request &amp;quot;/test.html&amp;quot;
with timeout 15 seconds
then restart
# если за последние пять циклов проверки было три рестарта или больше
# - пропускаем один цикл проверки.
if 3 restarts within 5 cycles then timeout
# проверку имеет смысл проводить только,
# если пройдена первая проверка (которая права доступа и проч).
# В противном случае все тесты безсмысленны.
depends on apache_bin
group server
&lt;/code>&lt;/pre>
&lt;p>OpenSSHD:&lt;/p>
&lt;pre>&lt;code>check process sshd with pidfile /var/run/sshd.pid
start program &amp;quot;/etc/init.d/ssh start&amp;quot;
stop program &amp;quot;/etc/init.d/ssh stop&amp;quot;
if failed port 22 protocol ssh then restart
if 5 restarts within 5 cycles then timeout
group server
&lt;/code>&lt;/pre>
&lt;p>OpenVPN. Проверяем только наличие процесса:&lt;/p>
&lt;pre>&lt;code>check process openvpn with pidfile /var/run/openvpn.link1.pid
group system
start program = &amp;quot;/etc/init.d/openvpn start&amp;quot;
stop program = &amp;quot;/etc/init.d/openvpn stop&amp;quot;
if 5 restarts within 5 cycles then timeout
&lt;/code>&lt;/pre>
&lt;p>PostgreSQL. Проверяем доступность через TCP-порт и сокет&lt;/p>
&lt;pre>&lt;code>check process postgres with pidfile /var/run/postgresql/main.pid
group database
start program = &amp;quot;/etc/init.d/postgresql start&amp;quot;
stop program = &amp;quot;/etc/init.d/postgresql stop&amp;quot;
if failed unixsocket /tmp/.s.PGSQL.5432 protocol pgsql then restart
if failed host 127.0.0.1 port 5432 protocol pgsql then restart
if 5 restarts within 5 cycles then timeout
group database
&lt;/code>&lt;/pre>
&lt;p>Исчерпывающий список протоколов и вариантов проверки можно почерпнуть в &lt;a href="http://mmonit.com/monit/documentation/monit.html">документации&lt;/a>. Правда, она на англ языке.&lt;/p>
&lt;h2 id="веб-интерфейс" >Веб-интерфейс
&lt;span>
&lt;a href="#%d0%b2%d0%b5%d0%b1-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d1%84%d0%b5%d0%b9%d1%81">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Как я уже писал во вступлении, у monit есть небольшая, но довольно полезная вебморда.
Пример настройки:&lt;/p>
&lt;pre>&lt;code>#включить веб-интерфейс на определенный порт
set httpd port 10001 and
#включить SSL
ssl enable
#где взять pem-файл. Нужен для ssl, подробно ниже
pemfile /etc/monit/monit.pem
#на каком адресе (интерфейсе) слушать.
#если адрес не указать - слушать будет на всех
use address 10.10.10.21
#разрешить доступ только с определенных адресов
#строго рекомендуется!
allow 10.10.10.22/32
allow 10.10.12.0/24
#разрешить доступ только знающим пароль.
#пароль, к сожалению, хранится в открытом виде
allow senegami:aoLouch0aingahce
allow logan:Jefae2Othaitae1S
&lt;/code>&lt;/pre>
&lt;p>Теперь о pem-файле. Веб-сервер monit довольно примитивный, и ему нужно иметь ssl сертификат, ключ от него и DH-файл в одном объекте. Собственно, он и называется pem-файлом. Готовится следующим образом. Сначала создадим шаблон для сертификата:&lt;/p>
&lt;pre>&lt;code>----- BEGIN:monit.cnf -----
RANDFILE = ./openssl.rnd
[ req ]
default_bits = 1024
encrypt_key = yes
distinguished_name = req_dn
x509_extensions = cert_type
[ req_dn ]
countryName = Country Name (2 letter code)
countryName_default = RU
stateOrProvinceName = State or Province Name (full name)
stateOrProvinceName_default = NorthWest
localityName= Locality Name (eg, city)
localityName_default= Saint Petersburg
organizationName= Organization Name (eg, company)
organizationName_default= AnyOne LLC
organizationalUnitName= Organizational Unit Name (eg, section)
organizationalUnitName_default= Net
commonName= Common Name (FQDN of your server)
commonName_default= ws1.zooclub.ru
emailAddress= Email Address
emailAddress_default= security@zooclub.ru
[ cert_type ]
nsCertType = server
----- END:monit.cnf -----
&lt;/code>&lt;/pre>
&lt;p>Разумеется, нужно поменять значения под необходимые конкретно вам&lt;/p>
&lt;p>Затем соберем из шаблона сертификат:&lt;/p>
&lt;pre>&lt;code>openssl req -new -x509 -days 720 -nodes \
-config ./monit.cnf -out /etc/monit/monit.pem \
-keyout /var/certs/monit.pem
#Генерируем число Диффи-Хеллмана и прячем его в тот же файл
openssl gendh 512 &amp;gt;&amp;gt; /etc/monit/monit.pem
#проверяем читаемость сертификата
openssl x509 -subject -dates -fingerprint -noout -in /etc/monit/monit.pem
#Поскольку в файле лежит серкретный ключ сертификата - уменьшим права доступа
chmod 400 /etc/monit/monit.pem
openssl gendh 512 &amp;gt;&amp;gt; /etc/monit/monit.pem
&lt;/code>&lt;/pre>
&lt;p>После чего перезапускаем монит и любуемся :)&lt;/p></description></item></channel></rss>