<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ruby on SRE Blog</title><link>https://prudnitskiy.pro/tags/ruby/</link><description>SRE Blog (ruby)</description><generator>Hugo -- gohugo.io</generator><language>ru-ru</language><lastBuildDate>Fri, 15 Sep 2017 21:40:00 +0000</lastBuildDate><atom:link href="https://prudnitskiy.pro/tags/ruby/index.xml" rel="self" type="application/rss+xml"/><item><title>Как (и зачем) перевести блог на статический сайт</title><link>https://prudnitskiy.pro/post/2017-09-15-jekyll/</link><pubDate>Fri, 15 Sep 2017 21:40:00 +0000</pubDate><guid>https://prudnitskiy.pro/post/2017-09-15-jekyll/</guid><description>&lt;p>Согласно &lt;a href="https://w3techs.com/technologies/overview/programming_language/all">статстике W3Tech&lt;/a> 98.5% современных сайтов – это динамические сайты. Строго говоря – это программы (порой – большие и сложные программы), мощные многоэтажные системы, связаные со сложными системами хранения данных. Каждое посещение такого сайта – это выполнение кода, что требует ресурсов сервера и времени. При этом реально в большинстве случаев вся эта мощь не используется – большинство сайтов довольно компактные и редко обновляются. А значит – мощная, сложная, гибкая, многокомпонентная, что самое страшное – потенциально ненадежная система, в общем-то, не нужна.&lt;/p>
&lt;p>Перевод сайта с динамики на статику – это простой и удобный способ обойтись без сложностей, не потеряв гибкости и удобства.&lt;/p>
&lt;h2 id="необязательная-предыстория" >Необязательная предыстория
&lt;span>
&lt;a href="#%d0%bd%d0%b5%d0%be%d0%b1%d1%8f%d0%b7%d0%b0%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d0%b0%d1%8f-%d0%bf%d1%80%d0%b5%d0%b4%d1%8b%d1%81%d1%82%d0%be%d1%80%d0%b8%d1%8f">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Когда интернет только появился – все сайты были сверстаны статически. Каждый сайт был простым набором физических файлов. Эти файлы лежали на физическом диске. При обращении к URL веб-сервер транслировал относительный путь в путь в файловой системе, физически читал файл с диска и отдавал его клиенту. Такой подход очень просто программируется, написать простейший web-server на любом современном языке можно за пару часов. При статической верстке очень легко управлять кешированием - достаточно читать атрибуты файла и отправлять их в заголовок. Проблемы начались с ростом объема сайта. Если вы создаете страницы по очереди - вы можете писать их руками, по одной. Проблемы начинаются, когда нужно поменять что-то во всех страницах разом. Десять страниц можно поменять руками. 20 - сложно. 100 - очень сложно. На пятой тысяче вы сильно пожалеете, что вообще вписались в эту задачу. Так же все эти файлы физически лежат на диске и занимают прорву места. Причем большая часть этих файлов - совершенно одинаковая (верстка и художественное оформление у страниц общее, отличаются они только содержанием).&lt;/p>
&lt;p>Для того, чтобы решить эту проблему - была придумана динамическая верстка и базы данных.&lt;/p>
&lt;p>Работало (и работает до сих пор) концептуально это очень просто:&lt;/p>
&lt;ul>
&lt;li>Запрос из сети вызывает выполнение кода на сервере (это и есть наш сайт, точнее - его часть).&lt;/li>
&lt;li>При выполнении код выясняет, какие данные требуются пользователю.&lt;/li>
&lt;li>Часть данных может быть прямо в коде (название сайта, имя автора, год публикации), а часть – лежит во внешнем хранилище, например - в базе данных.&lt;/li>
&lt;li>Код лезет в базу данных и вытаскивает оттуда нужные данные.&lt;/li>
&lt;li>Код загружает шаблон, на основе которого он будет рисовать страницу. Шаблон - это та же страница с версткой, дизайном и всеми атрибутами.В ней нет только реальных данных, вместо них там стоят метки вида &lt;code>{заголовок будет тут}&lt;/code>.&lt;/li>
&lt;li>Код вставляет в шаблон все необходимые данные и рисует страницу. Обычно готовая страница лежит в оперативной памяти сервера и ждет отдачи.&lt;/li>
&lt;li>Сервер получает от кода сообщение о готовности и отрисованую страницу.&lt;/li>
&lt;li>Сервер отдает страницу пользователю.&lt;/li>
&lt;/ul>
&lt;p>Современный сервер выполняет весь этот набор действий довольно быстро, но за конечное время. Обычно полный цикл занимает 100-200 миллисекунд + еще 50-100 миллисекунд требуется на доступ к базе. Проблемы начинаются на больших нагрузках. Либо резко кончаются ресурсы (каждый запрос обрабатывается независимым куском кода и в базу тоже ходит независимо). Либо сервер ставит запросы на обработку в очередь и сайт начинает тормозить (или вообще отваливается, если пользователь просто не успел дождаться своей очереди).&lt;/p>
&lt;p>Динамические сайты – это фантастически удобно. Когда данные лежат во внешнем хранилище – можно организовать туда доступ из нескольких мест. Например, сделать зоомагазины для кошек и для собак, но товары держать в общей базе. Это позволит показывать на каждом сайте уникальные для именно этого сайта товары + общие товары для обеих групп покупателей. Базы позволяют делать &amp;ldquo;срезы&amp;rdquo; данных по любому направлению. Это позволяет показать пользователю любой набор информации из базы, ограничив его любыми критериями. Данные всегда забираются из базы, а значит, обновив данные в базе мы моментально обновим их на сайте, никаких задержек. Динамические сайты используют для отображения шаблоны, а значит – не нужно муторно перерисовывать каждую страницу, если в ней нашлась какая-то проблема. Одна правка в одном месте сразу поправит все.&lt;/p>
&lt;p>По этой причине динамические сайты стали основой современного интернета. Статические сайты никто не делает, потому, что это неудобно и трудозатраты кажутся неадекватными. Однако, если собрать статистику по сайтам в интернете, выясняется, что:&lt;/p>
&lt;ul>
&lt;li>Подавляющее большинство сайтов имеет очень маленький размер – единицы, в редком случае десятки, в очень редком - сотни страниц. К примеру, возьмем блог. Это будет хороший блог очень обязательного человека, который пишет пост раз в неделю. В году всего 52 недели, то есть за каждый год существования блог вырастет на 52 страницы. За 10 лет - 520 страниц. Много ли вы видели десятилетних блогов?&lt;/li>
&lt;li>Подавляющее большинство сайтов очень редко обновляется, и им просто не нужна высокая легкость и скорость обновления.&lt;/li>
&lt;li>Подавляющее большинство сайтов очень редко посещается. Тут нужно сделать небольшое отступление и рассказать про кеш.&lt;/li>
&lt;/ul>
&lt;p>Идея кеширования в том, что если пользователи часто запрашивают некие данные - их проще не готовить по всей цепочке, а сохранить в уже подготовленном виде и отдавать сразу. Вместо 300 мсек на запрос получаем 10 мсек + освобождаем ресурсы сервера (так, как данные не надо готовить и отрисовывать, можно отдать уже готовую отрисованную страницу). Основная проблема кеша – его срок жизни. В момент, когда он создается, указывается, сколько времени должен жить объект. Когда объект закончит свое существование и будет удален - первый пользователь, который пойдет в обход кеша - вызовет запуск кода (и создание нового объекта). Отсюда вытекает две проблемы:&lt;/p>
&lt;ul>
&lt;li>Если сайт обновился - пользователи об этом не узнают, пока не умрет кешированный объект. Единственный способ избежать этого - при обновлении сайта найти и удалить объекты, которые ссылаются на необновленные данные.&lt;/li>
&lt;li>Если пользователи приходят редко - кеширование не имеет никакого смысла, потому, что объект кеша умрет раньше, чем его кто-то увидит.&lt;/li>
&lt;/ul>
&lt;p>При этом кеш сам по себе съедает ресурсы – для хранения кешированных объектов выделяется память, плюс кто-то должен выяснять, что отдавать пользователю – кешированный объект или идти к серверу за новым (и кешировать его).&lt;/p>
&lt;p>Еще одна серьезная проблема динамических сайтов – это безопасность. Динамический сайт – это код. В коде бывают ошибки. Более того – в коде &lt;em>вероятны&lt;/em> ошибки. Потенциально ошибка грозит утечкой данных сайта (в лучшем случае) или вовсе – захватом сервера, где сайт живет. Если у вас есть динамический сайт – вам нужен кто-то, кто будет следить за его состоянием. Обновлять код. Отслеживать попытки взлома и реагировать на них.&lt;/p>
&lt;p>Собственно, для решения этих проблем были придуманы генераторы статических сайтов. Это была попытка взять &amp;ldquo;лучшее из двух миров&amp;rdquo; – просту и легкость работы статического сайта и удобство работы с динамическими данными.&lt;/p>
&lt;h2 id="что-такое-jekyll" >Что такое Jekyll
&lt;span>
&lt;a href="#%d1%87%d1%82%d0%be-%d1%82%d0%b0%d0%ba%d0%be%d0%b5-jekyll">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Jekyll – один из многих генераторов статических сайтов. Генераторы пытаются совмещать несовемстимое – удобство обслуживания сайта динамического и легкость сайта, сверстанного статически. Работает это следующим образом:&lt;/p>
&lt;ul>
&lt;li>Данные для сайта сохраняются в виде текстовых файлов в специальном формате (он простой).&lt;/li>
&lt;li>Внешний вид и верстка сайта оформляется шаблонами (используется движок &lt;a href="https://shopify.github.io/liquid/">liquid&lt;/a> от shopify).&lt;/li>
&lt;li>Команда &lt;code>jekyll build&lt;/code> проверяет все данные и отрисовывает сайт по шаблону в виде набора статичных файлов. Готовые файлы сохраняются на диск.&lt;/li>
&lt;li>Готовые статичные файлы можно положить на сервер и сделать доступными в сети.&lt;/li>
&lt;/ul>
&lt;h3 id="когда-вам-нужен-jekyll-pros" >Когда вам нужен jekyll (pros)
&lt;span>
&lt;a href="#%d0%ba%d0%be%d0%b3%d0%b4%d0%b0-%d0%b2%d0%b0%d0%bc-%d0%bd%d1%83%d0%b6%d0%b5%d0%bd-jekyll-pros">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;ul>
&lt;li>Если у вас небольшой сайт (PR-страница, личный или корпоративный блог).&lt;/li>
&lt;li>Если ваш сайт обновляется сравнительно редко и делает это один человек (или несколько, но вы можете договорится о процедуре обновления).&lt;/li>
&lt;li>Если вам нужно очень сильно сэкономить (хостинг статических файлов можно найти бесплатно).&lt;/li>
&lt;li>Если сайт некрупный, но планируется &lt;strong>очень&lt;/strong> большая нагрузка (статический сайт будет обрабатываться быстрее динамического).&lt;/li>
&lt;li>Если вам очень важна безопасность, но нет средств на программиста, который будет поддерживать код вашего сайта (jekyll создает статические страницы, а на сервере никакой код не выполняется в принципе – ломать там нечего).&lt;/li>
&lt;/ul>
&lt;h3 id="когда-вам-не-нужен-jekyll-contras" >Когда вам не нужен jekyll (contras)
&lt;span>
&lt;a href="#%d0%ba%d0%be%d0%b3%d0%b4%d0%b0-%d0%b2%d0%b0%d0%bc-%d0%bd%d0%b5-%d0%bd%d1%83%d0%b6%d0%b5%d0%bd-jekyll-contras">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;ul>
&lt;li>Если у вас по-настоящему большой сайт и счет страниц идет на десятки тысяч. В принципе jekyll может работать с большими объемами данных, но это будет неудобно.&lt;/li>
&lt;li>Если ваш сайт обновляется очень часто (новостное агентство, форум).&lt;/li>
&lt;li>Если работа вашего сайта зависит от поведения пользователя на сайте (социальная сеть, персонализированные новости, интернет-магазин).&lt;/li>
&lt;li>Если ваш сайт обновляется многими и из многих точек (twitter, сервис блогов).&lt;/li>
&lt;li>Если нагрузка на ваш сайт по-настоящему велика и вы знаете, как заставить ваш код работать быстрее примитивной выгрузки данных с диска (да, это возможно). Но тогда я не понимаю, зачем вы вообще читаете эту простыню.&lt;/li>
&lt;/ul>
&lt;h2 id="установка" >Установка
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Для работы jekyll вам потребуется ruby, способов его установки настолько много, что я не буду на этом сейчас останавливаться. После установки ruby ставим гем jekyll:&lt;/p>
&lt;pre>&lt;code>&amp;gt; gem install jekyll
&lt;/code>&lt;/pre>
&lt;p>Теперь переходим в папку, где будет лежать сайт. На всякий случай напомню, что это не тот сайт, который будет доступен в сети, а тот, который служит источником данных. Создадим &amp;ldquo;пустой&amp;rdquo; сайт:&lt;/p>
&lt;pre>&lt;code>&amp;gt; jekyll new ./testsite
Running bundle install in ~/testsite...
Bundler: Fetching gem metadata from https://rubygems.org/...........
Bundler: Fetching version metadata from https://rubygems.org/..
Bundler: Fetching dependency metadata from https://rubygems.org/.
Bundler: Resolving dependencies...
Bundler: Fetching public_suffix 3.0.0
Bundler: Installing public_suffix 3.0.0
Bundler: Using bundler 1.15.2
Bundler: Using colorator 1.1.0
Bundler: Using ffi 1.9.18
Bundler: Using forwardable-extended 2.6.0
Bundler: Using rb-fsevent 0.10.2
Bundler: Fetching kramdown 1.15.0
Bundler: Installing kramdown 1.15.0
Bundler: Using liquid 4.0.0
Bundler: Using mercenary 0.3.6
Bundler: Using rouge 1.11.1
Bundler: Using safe_yaml 1.0.4
Bundler: Fetching addressable 2.5.2
Bundler: Installing addressable 2.5.2
Bundler: Using rb-inotify 0.9.10
Bundler: Using pathutil 0.14.0
Bundler: Fetching sass-listen 4.0.0
Bundler: Installing sass-listen 4.0.0
Bundler: Using listen 3.0.8
Bundler: Fetching sass 3.5.1
Bundler: Installing sass 3.5.1
Bundler: Using jekyll-watch 1.5.0
Bundler: Using jekyll-sass-converter 1.5.0
Bundler: Using jekyll 3.5.0
Bundler: Using jekyll-feed 0.9.2
Bundler: Using minima 2.1.1
Bundler: Bundle complete! 4 Gemfile dependencies, 22 gems now installed.
Bundler: Use `bundle info [gemname]` to see where a bundled gem is installed.
Bundler: The latest bundler is 1.16.0.pre.2, but you are currently running 1.15.2.
Bundler: To update, run `gem install bundler --pre`
New jekyll site installed in ~/testsite.
&lt;/code>&lt;/pre>
&lt;p>Самый простой способ убедится, что сайт создался и работает - собрать его. Команда &lt;code>jekyll serve&lt;/code> обработает имеющиеся данные и соберет статический сайт, а затем запустит маленький веб-сервер, чтобы можно было посмотреть на сайт. Эту команду надо выполнить внутри папки сайта:&lt;/p>
&lt;pre>&lt;code>&amp;gt; cd ./testsite
&amp;gt; jekyll serve
Configuration file: /home/testsite/_config.yml
Deprecation: The 'gems' configuration option has been renamed to 'plugins'. Please update your config file accordingly.
Source: /home/testsite
Destination: /home/testsite/_site
Incremental build: disabled. Enable with --incremental
Generating...
done in 0.812 seconds.
Auto-regeneration: enabled for '/home/testsite'
Server address: http://127.0.0.1:4000/
Server running... press ctrl-c to stop.
&lt;/code>&lt;/pre>
&lt;p>Теперь можно зайти браузером на &lt;code>http://127.0.0.1:4000&lt;/code> и полюбоваться на сайт:&lt;/p>
&lt;p>![jekyll new]({{ site.baseurl }}{% link /assets/img/jekyll-new.png %})&lt;/p>
&lt;h2 id="быстрый-старт" >Быстрый старт
&lt;span>
&lt;a href="#%d0%b1%d1%8b%d1%81%d1%82%d1%80%d1%8b%d0%b9-%d1%81%d1%82%d0%b0%d1%80%d1%82">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Jekyll изначально - движок для блогов. Это не значит, что на нем можно писать только блоги, просто с блогами там работать легче всего. Все блог-посты, которые будут видны на сайте, jekyll ищет в каталоге &lt;code>_posts&lt;/code>. Название у файла должно соответствовать шаблону &lt;code>YYYY-MM-DD-slug.md&lt;/code>, где:&lt;/p>
&lt;ul>
&lt;li>YYYY год в четырехсимвольном формате (2010)&lt;/li>
&lt;li>MM месяц в двухсимвольном формате (03 – март).&lt;/li>
&lt;li>DD в двухсимвольном формате (08 - 8 Марта).&lt;/li>
&lt;li>slug - произвольное название статьи на английском языке. Регистр букв (большая-маленькая) – учитываться не будет. Реально slug нужен на тот случай, если у вас два сообщения в один день.&lt;/li>
&lt;li>md - подсказка, что это формат markdown. Jekyll поддерживает и другие форматы, но в данном примере я буду рассматривать markdown, он очень простой.&lt;/li>
&lt;/ul>
&lt;p>Заголовок (шапка) файла тоже имеет определенные требования, вот пример:&lt;/p>
&lt;pre>&lt;code>---
layout: post
title: &amp;quot;Текст про 8 марта&amp;quot;
date: &amp;quot;2010-03-08 8:00:00+03:00&amp;quot;
---
&lt;/code>&lt;/pre>
&lt;p>Что тут написано:&lt;/p>
&lt;ul>
&lt;li>&lt;code>layout: post&lt;/code> указывает jekyll, какой шаблон нужно использовать для отрисовки (перевода) данного статического текста в html-страницу. Post - стандартный шаблон, который идет в комплекте, и если нет уверенности – проще всего брать его.&lt;/li>
&lt;li>&lt;code>title&lt;/code> - это заголовок страницы. Именно этот текст будет отображен в списке постов на главной странице и именно этот текст будет в шапке страницы, когда пользователь ее откроет.&lt;/li>
&lt;li>&lt;code>date&lt;/code> - дата и время публикации. Время указывается в 24-формате с точностью до секунды, через &lt;code>+&lt;/code> (или &lt;code>-&lt;/code>) указывается тайм-зона. Ее указывать не обязательно, но тогда будет использоваться та, что указана в настройках. Эти дата и время будут показаны на сайте. Если их не указать – дата публикации будет взята из названия файла (если указать - из этого поля, а дата из названия будет игнорироваться).&lt;/li>
&lt;/ul>
&lt;p>Пропускаем строку после заголовка и можно писать текст&lt;/p>
&lt;h3 id="лирическое-отступление-markdown" >Лирическое отступление: markdown
&lt;span>
&lt;a href="#%d0%bb%d0%b8%d1%80%d0%b8%d1%87%d0%b5%d1%81%d0%ba%d0%be%d0%b5-%d0%be%d1%82%d1%81%d1%82%d1%83%d0%bf%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-markdown">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Markdown – это простой язык разметки. Он нужен для того, чтобы разделять в тексте заголовки и абзацы, делать текст &lt;strong>жирным&lt;/strong> или &lt;em>курсивным&lt;/em>. HTML, на котором написаны страницы, которые лежат в интернете – тоже язык разметки. Но HTML – язык сложный, мощный, гибкий и не прощающий ошибок. Markdown – напротив, специально сделан предельно простым, пусть и в ущерб гибкости.&lt;/p>
&lt;p>Markdown прекрасно понимает переносы строк. Нужно отделить один абзац от другого – достаточно одной пустой строки между ними.&lt;/p>
&lt;p>Для заголовков используется символ &lt;code>#&lt;/code>. Ставится он только с одной стороны и заголвок считается только с новой строки. Пример:&lt;/p>
&lt;ul>
&lt;li>&lt;code># заголовок&lt;/code> заголовок первого уровня (H1). Самый крупный.&lt;/li>
&lt;li>&lt;code>## заголовок поменьше&lt;/code> - заголовок второго уровня (h2). Поменьше.&lt;/li>
&lt;li>&lt;code>### подзаголовок&lt;/code> - заголовок третьего уровня. Самый маленький.&lt;/li>
&lt;/ul>
&lt;p>Для оформления текста внутри абзаца:&lt;/p>
&lt;ul>
&lt;li>&lt;code>**жирный**&lt;/code> - две звездочки сделают текст жирным (&lt;strong>bold&lt;/strong>).&lt;/li>
&lt;li>&lt;code>*курсивный*&lt;/code> - одна звездочка сделает текст наклонным (&lt;em>italic&lt;/em>)&lt;/li>
&lt;li>&lt;code>***жирный и курсивный***&lt;/code> - три звездочки сделают текст и жирным и курсивным &lt;em>&lt;strong>сразу&lt;/strong>&lt;/em>&lt;/li>
&lt;/ul>
&lt;p>Для ссылок:&lt;/p>
&lt;ul>
&lt;li>&lt;code>[ссылка обычная](https://yandex.ru)&lt;/code> - создаст обычную ссылку. Текст будет взят из &lt;code>[]&lt;/code>, а вести она будет по адресу &lt;code>()&lt;/code>.&lt;/li>
&lt;li>&lt;code>![картинка](https://yandex.ru/image.jpg)&lt;/code> - на странице появится картинка. Обратите внимание на &lt;code>!&lt;/code> в начале.&lt;/li>
&lt;/ul>
&lt;p>Чтобы создать список - начинайте строку с символа &lt;code>-&lt;/code> или &lt;code>*&lt;/code> и пробела за ним. Если у вас группа строк идет без разрыва, одна за другой – это будет воспринято как список:&lt;/p>
&lt;pre>&lt;code>- первый пункт
- второй
- третий
тут немного текста
- первый пункт второго списка
- второй пункт второго списка
&lt;/code>&lt;/pre>
&lt;p>Полное описание стандарта можно найти &lt;a href="https://daringfireball.net/projects/markdown/syntax">вот тут&lt;/a> (на английском языке). Существует огромное количество текстовых редакторов с поддержкой markdown, которые прямо во время редактирования показывают, каким будет оформление текста. Лично я пишу этот текст в прекрасном редакторе Sublime3.&lt;/p>
&lt;h3 id="настройки-сайта" >Настройки сайта
&lt;span>
&lt;a href="#%d0%bd%d0%b0%d1%81%d1%82%d1%80%d0%be%d0%b9%d0%ba%d0%b8-%d1%81%d0%b0%d0%b9%d1%82%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Глобальные настройки сайта находятся в файле &lt;code>_config.yml&lt;/code>. Он довольно очевидный и легко читается. Что я рекомендую в нем поменять:&lt;/p>
&lt;ul>
&lt;li>title - заголовок сайта. Отображается на каждой странице&lt;/li>
&lt;li>description - описание сайта. Отображается на каждой странице стандартного шаблона внизу экрана&lt;/li>
&lt;li>email, twitter_username, github_username - необязательные поля. Если есть - отображаются внизу экрана.&lt;/li>
&lt;li>url - адрес вашего сайта в сети. Важен для внутренних ссылок.&lt;/li>
&lt;li>baseurl - нужен в том случае, если jekyll является не основным сайтом, а только его частью и расположен в отдельной локации (к пример - по адресу &lt;code>/blog/&lt;/code>). Baseurl будет автоматически добавляется перед началом каждого адреса, который есть в jekyll. Это довольно редкая настройка.&lt;/li>
&lt;li>timezone - временная зона по умолчанию, задается в стандартном виде &lt;code>Регион/Город&lt;/code>. Типичная настройка для европейской части России - &lt;code>Europe/Moscow&lt;/code>.&lt;/li>
&lt;/ul>
&lt;p>Обычно настройки достаточно поменять один раз.&lt;/p>
&lt;h3 id="дополнительные-страницы" >Дополнительные страницы
&lt;span>
&lt;a href="#%d0%b4%d0%be%d0%bf%d0%be%d0%bb%d0%bd%d0%b8%d1%82%d0%b5%d0%bb%d1%8c%d0%bd%d1%8b%d0%b5-%d1%81%d1%82%d1%80%d0%b0%d0%bd%d0%b8%d1%86%d1%8b">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Обычно в блоге кроме собственно постов есть статические страницы, например – описание сайта или страница контактов. Jekyll позволяет создать такие страницы. Эти страницы не отображаются в списке постов на главной, но зато они видны в шапке сайта (сверху). Такие страницы нужно создавать прямо в корне (папке, где находятся все файлы jekyll) и в их названии не обязательно должна быть дата, достаточно просто имени и расширения md. Имя должно содержать только английские буквы, точку и тире (в противном случае могут быть сюрпризы). У страницы в заголовке должен быть обязательный атрибут &lt;code>permalink&lt;/code> – это указание jekyll, по какому адресу эта страница должна быть видна на сайте. В остальном такие файлы ничем не отличаются от файлов блог-постов, которые я описывал выше.&lt;/p>
&lt;h3 id="генерация-и-выкладка" >Генерация и выкладка
&lt;span>
&lt;a href="#%d0%b3%d0%b5%d0%bd%d0%b5%d1%80%d0%b0%d1%86%d0%b8%d1%8f-%d0%b8-%d0%b2%d1%8b%d0%ba%d0%bb%d0%b0%d0%b4%d0%ba%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>Итак, текст написан, можем выкладывать. Чтобы собрать сайт из страниц-заготовок - используйте команду &lt;code>jekyll build&lt;/code>. Ответ будет выглядеть примерно так:&lt;/p>
&lt;pre>&lt;code>&amp;gt; jekyll build
Configuration file: /home/testsite/_config.yml
Source: /home/testsite
Destination: /home/testsite/_site
Incremental build: disabled. Enable with --incremental
Generating...
done in 1.683 seconds.
Auto-regeneration: disabled. Use --watch to enable.
&lt;/code>&lt;/pre>
&lt;p>В нормальном состоянии jekyll не должен как-то ругаться, выбрасывать предупреждения или ошибки. Если они все же есть – рекомендую их внимательно прочитать. Обычно прямо в тексте ошибки есть указание на то, как ее исправить.&lt;/p>
&lt;p>Готовые к выкладке файлы будут ждать в папке &lt;code>_site&lt;/code>. Теперь достаточно просто скопировать их на хостинг (подойдет совершенно любой хостинг, который позволяет загружать на него файлы) - и сайт доступен в интернете. На хостинг нужно отправлять только содержимое папки &lt;code>_site&lt;/code>, ничего больше отправлять не нужно! Для размещения сайта можно, например, использовать совершенно бесплатный &lt;a href="https://pages.github.com/">github pages&lt;/a>, но в принципе – найти хостинг бесплатный или очень дешевый хостинг - несложно. Благо, все, что от него требуется – возможность хоть в каком-то виде отправлять на него файлы.&lt;/p>
&lt;h3 id="добавление-удаление-контента" >Добавление-удаление контента
&lt;span>
&lt;a href="#%d0%b4%d0%be%d0%b1%d0%b0%d0%b2%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d1%83%d0%b4%d0%b0%d0%bb%d0%b5%d0%bd%d0%b8%d0%b5-%d0%ba%d0%be%d0%bd%d1%82%d0%b5%d0%bd%d1%82%d0%b0">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h3>&lt;p>В обновлении сайта нет ничего сложного, но на всякий случай я опишу его тезисно:&lt;/p>
&lt;ul>
&lt;li>пишем новый текст. Файл кладем в &lt;code>_posts&lt;/code>, если это запись в блоге или в корень сайта на жестком диске, если это – простая страница&lt;/li>
&lt;li>выполняем &lt;code>jekyll build&lt;/code>, чтобы пересобрать сайт&lt;/li>
&lt;li>загружаем содержимое папки &lt;code>_site&lt;/code> на хостинг. Если какие-то файлы на хостинге уже есть с прошлого раза – перезаписываем.&lt;/li>
&lt;li>сайт обновлен и готов к использованию&lt;/li>
&lt;/ul></description></item><item><title>Запуск ruby on rails на uwsgi на примере redmine</title><link>https://prudnitskiy.pro/post/2013-06-20-rails-on-uwsgi/</link><pubDate>Thu, 20 Jun 2013 19:49:52 +0000</pubDate><guid>https://prudnitskiy.pro/post/2013-06-20-rails-on-uwsgi/</guid><description>&lt;p>Для лично-рабочих нужд я активно использую task-tracking system под названием Redmine. Redmine практически всем хорош из открытых трекеров, но очень любит память. Традиционно он запускается через rails server (WEBRick) или rails-specific сервер thin. Во второй конфигурации у меня он жрал 300Мб оперативной памяти, а среднее время генерации страницы было близко к секунде, что совершенно неприемлимо. По этой причине я решил использовать uwsgi - совершенно прекрасный appserver, который я активно использую для своего творчества на python. Uwsgi работает очень быстро (действительно - очень!), достаточно экономно относится к памяти, обладает широчайшими возможностями конфигурирования - просто-таки мечта, а не сервер. До недавнего времени он умел работать только с python (под который интерфейс uWSGI, строго говоря, и создавался), но теперь умеет обрабатывать ruby и даже PHP. Минусом uwsgid является, во-первых, тот факт, что он находится на переднем крае разработок, а значит - может работать ой как своеобразно. Не менее своеобразно он настраивается, и документации по нему очень мало.&lt;/p>
&lt;h2 id="идея" >Идея
&lt;span>
&lt;a href="#%d0%b8%d0%b4%d0%b5%d1%8f">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Запускать будем redmine, но это типовое rails приложение, все остальные запускаются так же. В качестве веб-сервера - nginx, апп-сервер - uwsgid, база данных - postgresql (но будет уточнение для mysql), для управления uwsgid будем использовать supervisord&lt;/p>
&lt;h2 id="зависимости" >Зависимости
&lt;span>
&lt;a href="#%d0%b7%d0%b0%d0%b2%d0%b8%d1%81%d0%b8%d0%bc%d0%be%d1%81%d1%82%d0%b8">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Ставим системные компоненты:&lt;/p>
&lt;pre>&lt;code>apt-get update
apt-get install gcc cpp make nginx
#postgresql
apt-get install postgresql libpq-dev
#или mysql
apt-get install mysql libmysqlclient-dev
&lt;/code>&lt;/pre>
&lt;p>Лирическое отступление: я рекомендую использовать rvm вместо штатного руби. RVM живет вне пакетов, и обновлять его надо вручную, однако он позволяет получить самую свежую версию ruby, кроме того - он позволяет использовать несколько разных версий языка, а так же - несколько разных наборов библиотек (gem), не пересекая их друг с другом. Если у вас несколько приложений на ruby делят один сервер - это крайне удобный функционал.&lt;/p>
&lt;p>Ставим ruby:&lt;/p>
&lt;pre>&lt;code>#системная версия
apt-get install ruby1.8 ruby1.8-dev rubygems
#ИЛИ rvm
curl -L https://get.rvm.io | bash -s stable
rvm install 1.9.3-p429
&lt;/code>&lt;/pre>
&lt;p>Теперь доустанавливаем gem bundle. Он отвечает за установку необходимых для работы веб-приложения библиотек&lt;/p>
&lt;pre>&lt;code>gem install bundle
&lt;/code>&lt;/pre>
&lt;h2 id="установка-redmine" >Установка Redmine
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-redmine">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Создадим базу данных и пользователя для работы с ней:&lt;/p>
&lt;pre>&lt;code>#вариант для postgresql
sudo -u postgres psql
psql# create user redmineuser nocreatedb nocreateuser;
psql# alter role redmineuser with password 'MySecretP@ssw0rd';
psql# create database redminedb owner redmineuser;
#вариант для mysql
mysql -p
mysql&amp;gt; create database redminedb;
mysql&amp;gt; grant all on redminedb.* to redmineuser@localhost identified by 'MySecretP@ssw0rd';
mysql&amp;gt; flush privileges;
&lt;/code>&lt;/pre>
&lt;p>Теперь скачиваем и ставим сам redmine. Последнюю версию берем [http://rubyforge.org/frs/?group_id=1850] тут.&lt;/p>
&lt;pre>&lt;code>wget http://rubyforge.org/frs/download.php/76933/redmine-2.3.1.tar.gz
tar -xf redmine-2.3.1.tar.gz
mv redmine-2.3.1 redmine
&lt;/code>&lt;/pre>
&lt;p>Для корректной работы надо исправить файл config/database.yml в корне приложения. Вот пример для postgresql:&lt;/p>
&lt;pre>&lt;code>production:
adapter: postgresql
database: redminedb
host: localhost
username: redmineuser
password: MySecretP@ssw0rd
encoding: utf8
schema_search_path: public
&lt;/code>&lt;/pre>
&lt;p>А вот пример для mysql:&lt;/p>
&lt;pre>&lt;code>production:
adapter: mysql
database: redminedb
host: localhost
username: redmineuser
password: MySecretP@ssw0rd
encoding: utf8
&lt;/code>&lt;/pre>
&lt;p>Теперь самое сложное - установка GEM-ов. Gem - это библиотека в терминологии ruby. Их количество без преувеличения огромно, и делают они буквально все - appservers, драйвера к библиотекам, рисование графиков&amp;hellip; Любое нормальное руби-приложение использует множество гемов для работы. Для упрощения установки используется (сюрприз!) gem под названием bundle.
Заходим в папку redmine и выполняем:&lt;/p>
&lt;pre>&lt;code>#вариант для postgresql
bundle install --without development test sqlite mysql rmagick
#ИЛИ для mysql
bundle install --without development test sqlite pg rmagick
&lt;/code>&lt;/pre>
&lt;p>Запуск приложения (любого!) от root не рекомендуется, так как взлом этого приложения скомпрометирует систему полностью.
Сделаем непривелигированного юзера:&lt;/p>
&lt;pre>&lt;code>useradd --system -m -d /var/www/redmine -s /bin/bash redmine
&lt;/code>&lt;/pre>
&lt;p>Послеустановочные действия:&lt;/p>
&lt;pre>&lt;code>rake generate_secret_token
RAILS_ENV=production rake db:migrate
RAILS_ENV=production rake redmine:load_default_data
mkdir -p tmp tmp/pdf public/plugin_assets
chown -R redmine:redmine files log tmp public/plugin_assets
chmod -R 755 files log tmp public/plugin_assets
&lt;/code>&lt;/pre>
&lt;h2 id="установка-и-подключение-uwsgid" >Установка и подключение uwsgid
&lt;span>
&lt;a href="#%d1%83%d1%81%d1%82%d0%b0%d0%bd%d0%be%d0%b2%d0%ba%d0%b0-%d0%b8-%d0%bf%d0%be%d0%b4%d0%ba%d0%bb%d1%8e%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-uwsgid">
&lt;svg viewBox="0 0 28 23" height="100%" width="19" xmlns="http://www.w3.org/2000/svg">&lt;path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" fill="none" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2"/>&lt;/svg>
&lt;/a>
&lt;/span>
&lt;/h2>&lt;p>Ставим uwsgid. Его придется ставить из gem, потому, что тот, что идет в комплекте с системой, слишком старый - и не умеет работать с rails&lt;/p>
&lt;pre>&lt;code>gem install uwsgi
&lt;/code>&lt;/pre>
&lt;p>Конфигурация uwsgi расскажет ему о том, как запустить rails. Пишем в файл uwsgi.ini&lt;/p>
&lt;pre>&lt;code>[uwsgi]
socket = /tmp/redmine.sock
chmod-socket = 770
master = true
lazy = true
processes = 2 #по количеству ядер в системе. У меня atom 525, два ядра
post-buffering = 4096
#следующие три строки - только для тех, кто использует RVM
rvm-path = /usr/local/rvm
#имя ruby, указывать обязательно, даже, если он указан по умолчанию
rvm = ruby-1.9.3-p429
#название gemset в формате язык@гемсет
gemset = ruby-1.9.3-p429@redmine
uid = redmine
gid = www-data
env = RAILS_ENV=production
chdir = /var/www/redmine
rack = /var/www/redmine/config.ru
http-modifier1 = 7
&lt;/code>&lt;/pre>
&lt;p>Сам по себе supervisor умеет порождать процессы-обработчики (это так называемый режим императора), но это совсем молодая фишка и работает она&amp;hellip; Ну, как любая совсем новая фишка. Лично я рекомендую использовать для управления supervisord. Его задача - запускать и останавливать другие процессы (в данном контексте - uwsgi). Он обладает очень простым (если не сказать - примитивным) конфигурационным файлом и очень прост в работе. Устанавливаем:&lt;/p>
&lt;pre>&lt;code>apt-get install supervisord
/etc/init.d/supervisor start
&lt;/code>&lt;/pre>
&lt;p>Теперь нам надо создать конфиг для нашего приложения. В папке &lt;code>/etc/supervisor/conf.d&lt;/code> создаем файл с произвольным именем и окончанием .conf. Содержимое:&lt;/p>
&lt;pre>&lt;code>[program:redmine]
directory=/var/www/redmine
command=uwsgi --ini /var/www/redmine/uwsgi.ini
autostart=true
&lt;/code>&lt;/pre>
&lt;p>Теперь его надо подключить. У supervisord есть собственная консоль, она называется supervisorctl. Заходим:&lt;/p>
&lt;pre>&lt;code>supervisorctl
#поиск новых конфигов
supervisor&amp;gt; reread
#нашелся
redmine: available
#добавляем
supervisor&amp;gt; add redmine
redmine: added process group
#проверим, работает?
supervisor&amp;gt; status
redmine BACKOFF can't find command 'uwsgi'
&lt;/code>&lt;/pre>
&lt;p>Не находится он потому, что supervisorctl не может найти rvm-версию uwsgi. Ок, укажем вручную:&lt;/p>
&lt;pre>&lt;code>find / -name uwsgi
[...]
/usr/local/rvm/gems/ruby-1.9.3-p429/bin/uwsgi
[...]
&lt;/code>&lt;/pre>
&lt;p>Вносим изменения в наш конфиг &lt;code>/etc/supervisor/conf.d/redmine.conf&lt;/code>. Теперь он выглядит так:&lt;/p>
&lt;pre>&lt;code>[program:redmine]
directory=/var/www/redmine
command=/usr/local/rvm/gems/ruby-1.9.3-p429/bin/uwsgi --ini /var/www/redmine/uwsgi.ini
autostart=true
&lt;/code>&lt;/pre>
&lt;p>Обновим конфиг без перезагрузки supervisord:&lt;/p>
&lt;pre>&lt;code>supervisorctl update redmine
supervisorctl status
[...]
redmine RUNNING pid 25365, uptime 0:00:18
[...]
&lt;/code>&lt;/pre>
&lt;p>Отлично, uwsgi работает, подключаем nginx. Debian-way предполагает, что конфигурации сайтов находятся в отдельных файлах каталога /etc/nginx/sites-enabled. Содержимое /etc/nginx/sites-enabled/redmine&lt;/p>
&lt;pre>&lt;code>server {
listen 80;
server_name redmine.office;
location @redmine {
uwsgi_modifier1 7;
include uwsgi_params;
uwsgi_pass unix:///tmp/redmine.sock;
}
location / {
root /var/www/redmine/public;
try_files $uri $uri/index.html $uri.html @redmine;
}
}
&lt;/code>&lt;/pre>
&lt;p>Кроме того, потребуется описание типовых параметров uwsgi, файл /etc/nginx/uwsgi_params&lt;/p>
&lt;pre>&lt;code>uwsgi_param QUERY_STRING $query_string;
uwsgi_param REQUEST_METHOD $request_method;
uwsgi_param CONTENT_TYPE $content_type;
uwsgi_param CONTENT_LENGTH $content_length;
uwsgi_param REQUEST_URI $request_uri;
uwsgi_param PATH_INFO $document_uri;
uwsgi_param DOCUMENT_ROOT $document_root;
uwsgi_param SERVER_PROTOCOL $server_protocol;
uwsgi_param UWSGI_SCHEME $scheme;
uwsgi_param REMOTE_ADDR $remote_addr;
uwsgi_param REMOTE_PORT $remote_port;
uwsgi_param SERVER_PORT $server_port;
uwsgi_param SERVER_NAME $server_name;
&lt;/code>&lt;/pre>
&lt;p>Теперь достаточно перезапустить nginx - и редмайн готов к использованию!&lt;/p></description></item></channel></rss>